head(area4.tra)
head(ANOSIMReplicates)
attach(ANOSIMReplicates)
ANOSIMReplicates <- ANOSIMReplicates[order(Site),] #Reorder so sites are sorted alphabetically
head(ANOSIMReplicates)
detach(ANOSIMReplicates)
head(ANOSIMReplicates)
ANOSIMReplicates$Sample.Number <- rownames(ANOSIMReplicates) #Extract row names
head(ANOSIMReplicates)
attach(ANOSIMReplicates)
ANOSIMReplicates <- ANOSIMReplicates[order(Sample.Number),] #Reorder by sample number
head(ANOSIMReplicates)
detach(ANOSIMReplicates)
area4.tra
area4.tra$Sample.Number <- rownames(area4.tra) #Extract row names
head(area4.tra)
pairwiseData <- merge(x = area4.tra, y = ANOSIMReplicates, by = "Sample.Number") #Merge dataframes
head(pairwiseData) #Confirm merge
rownames(pairwiseData) <- pairwiseData$Sample.Number #Make sample number the rownames
head(pairwiseData) #Confirm merge
pairwiseData <- pairwiseData[, -1] #Remove Sample.Number column
head(pairwiseData) #Confirm merge
dataCIFB <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "FB", ] #Subset data
dataCIFB$Site <- factor(dataCIFB$Site) #Make sure only present factors are recognized
head(dataCIFB)
siteCIFBANOSIM <- anosim(dataCIFB[,1:37], grouping = dataCIFB[,38])
siteCIFBANOSIM$statistic #R = 0.0645419
siteCIFBANOSIM$signif #p = 0.065
plot(siteCIFBANOSIM) #Obtain boxplots and permutation test histogram
summary(siteCIFBANOSIM)
dataCIPG <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "PG", ] #Subset data
dataCIPG$Site <- factor(dataCIPG$Site) #Make sure only present factors are recognized
head(dataCIPG) #Confirm changes
siteCIPGANOSIM <- anosim(dataCIPG[,1:37], grouping = dataCIFB[,38])
summary(siteCIPGANOSIM)
siteCIPGANOSIM$statistic #R = 0.0196793
siteCIPGANOSIM$signif #p = 0.331
plot(siteCIPGANOSIM) #Obtain boxplots and permutation test histogram
dataCISK <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "SK", ] #Subset data
dataCISK$Site <- factor(dataCISK$Site) #Make sure only present factors are recognized
head(dataCISK) #Confirm changes
siteCISKANOSIM <- anosim(dataCISK[,1:37], grouping = dataCIFB[,38])
summary(siteCISKANOSIM)
siteCISKANOSIM$statistic #R = -0.07069971
siteCISKANOSIM$signif #p = 0.774
plot(siteCISKANOSIM) #Obtain boxplots and permutation test histogram
dataCIWB <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "WB", ] #Subset data
dataCIWB$Site <- factor(dataCIWB$Site) #Make sure only present factors are recognized
head(dataCIWB) #Confirm changes
siteCIWBANOSIM <- anosim(dataCIWB[,1:37], grouping = dataCIFB[,38])
summary(siteCIWBANOSIM)
siteCIPGANOSIM <- anosim(dataCIPG[,1:37], grouping = dataCIPG[,38])
summary(siteCIPGANOSIM)
siteCIPGANOSIM$statistic #R = -0.07069971
siteCIPGANOSIM$signif #p = 0.774
dataCISK <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "SK", ] #Subset data
dataCISK$Site <- factor(dataCISK$Site) #Make sure only present factors are recognized
head(dataCISK) #Confirm changes
siteCISKANOSIM <- anosim(dataCISK[,1:37], grouping = dataCISK[,38])
summary(siteCISKANOSIM)
siteCISKANOSIM$statistic #R = -0.0393586
siteCISKANOSIM$signif #p = 0.615
dataCIWB <- pairwiseData[pairwiseData$Site == "CI" | pairwiseData$Site == "WB", ] #Subset data
dataCIWB$Site <- factor(dataCIWB$Site) #Make sure only present factors are recognized
head(dataCIWB) #Confirm changes
siteCIWBANOSIM <- anosim(dataCIWB[,1:37], grouping = dataCIWB[,38])
summary(siteCIWBANOSIM)
siteCIWBANOSIM$statistic #R = -0.0393586
siteCIWBANOSIM$signif #p = 0.615
plot(siteCIWBANOSIM) #Obtain boxplots and permutation test histogram
dataFBPG <- pairwiseData[pairwiseData$Site == "FB" | pairwiseData$Site == "PG", ] #Subset data
dataFBPG$Site <- factor(dataFBPG$Site) #Make sure only present factors are recognized
head(dataFBPG) #Confirm changes
siteFBPGANOSIM <- anosim(dataFBPG[,1:37], grouping = dataFBPG[,38])
siteFBPGANOSIM$statistic #R = -0.07069971
siteFBPGANOSIM$signif #p = 0.78
dataFBSK <- pairwiseData[pairwiseData$Site == "FB" | pairwiseData$Site == "SK", ] #Subset data
dataFBSK$Site <- factor(dataFBSK$Site) #Make sure only present factors are recognized
head(dataFBSK) #Confirm changes
siteFBPGANOSIM <- anosim(dataFBSK[,1:37], grouping = dataFBSK[,38])
siteFBPGANOSIM <- anosim(dataFBPG[,1:37], grouping = dataFBPG[,38])
siteFBSKANOSIM <- anosim(dataFBSK[,1:37], grouping = dataFBSK[,38])
siteFBSKANOSIM$statistic #R = -0.03125
siteFBSKANOSIM$signif #p = 0.599
dataFBWB <- pairwiseData[pairwiseData$Site == "FB" | pairwiseData$Site == "WB", ] #Subset data
siteFBWBANOSIM <- anosim(dataFBWB[,1:37], grouping = dataFBWB[,38])
siteFBWBANOSIM$statistic #R = 0.09486607
siteFBWBANOSIM$signif #p = 0.086
dataPGSK <- pairwiseData[pairwiseData$Site == "PG" | pairwiseData$Site == "SK", ] #Subset data
dataPGSK$Site <- factor(dataPGSK$Site) #Make sure only present factors are recognized
head(dataPGSK) #Confirm changes
sitePGSKANOSIM <- anosim(dataPGSK[,1:37], grouping = dataPGSK[,38])
sitePGSKANOSIM$statistic #R = 0.09486607
sitePGSKANOSIM$signif #p = 0.086
dataPGWB <- pairwiseData[pairwiseData$Site == "PG" | pairwiseData$Site == "WB", ] #Subset data
dataPGWB$Site <- factor(dataPGWB$Site) #Make sure only present factors are recognized
head(dataPGWB) #Confirm changes
sitePGWBANOSIM <- anosim(dataPGWB[,1:37], grouping = dataPGWB[,38])
sitePGWBANOSIM$statistic #R = -0.006138393
sitePGWBANOSIM$signif #p = 0.382
plot(sitePGWBANOSIM) #Obtain boxplots and permutation test histogram
dataSKWB <- pairwiseData[pairwiseData$Site == "SK" | pairwiseData$Site == "WB", ] #Subset data
dataSKWB$Site <- factor(dataSKWB$Site) #Make sure only present factors are recognized
head(dataSKWB) #Confirm changes
siteSKWBANOSIM <- anosim(dataSKWB[,1:37], grouping = dataSKWB[,38])
siteSKWBANOSIM$statistic #R = 0.07267442
siteSKWBANOSIM$signif #p = 0.192
knitr::opts_chunk$set(echo = TRUE)
#install.packages("vegan")
require(vegan)
#install.packages("cluster")
require(cluster)
source("../../biostats.R") #Load biostats file
sessionInfo()
knitr::opts_chunk$set(echo = TRUE)
#install.packages("vegan")
require(vegan)
#install.packages("cluster")
require(cluster)
source("../../biostats.R") #Load biostats file
sessionInfo()
tideData <- read.csv("../../../../data/DNR/2017-12-13-Tidal-Data-by-Site.csv", header = TRUE, strip.white = TRUE) #Import the tide data
tideData$Date <- as.Date(tideData$Date, format = "%m/%d/%y") #Convert entries to dates
tideData$DateTime <- paste(tideData$Date, tideData$Time) #Create new DateTime column to easily merge tide and environmental data
colnames(tideData) <- c("Date", "Time", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide", "DateTime")
head(tideData) #Confirm changes
pHDOData <- read.csv("../../../../data/DNR/2017-11-14-Environmental-Data-from-Micah.csv", header = TRUE, na.strings = "NA") #Import file with pH and DO data
colnames(pHDOData) #View column names
pHData <- pHDOData[,c(2:3, 4:12)] #Subset only the bare and eelgrass outplant pH data
head(pHData) #Confirm subset
colnames(pHData) <- c("Date", "Time", "WBE-pH", "WBB-pH", "SKE-pH", "SKB-pH", "PGB-pH", "CIE-pH", "CIB-pH", "FBE-pH", "FBB-pH") #Rename columns
pHData$Date <- as.Date(pHData$Date, format = "%m/%d/%y") #Convert entries to dates
pHData <- pHData[pHData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
pHData$DateTime <- paste(pHData$Date, pHData$Time) #Create new DateTime column to easily merge tide and environmental data
head(pHData) #Confirm changes
DOData <- pHDOData[,c(2:3, 22:31)] #Subset the bare and eelgrass outplant DO data
head(DOData) #Confirm subset
colnames(DOData) <- c("Date", "Time", "WBE-DO", "WBB-DO", "SKE-DO", "SKB-DO", "PGE-DO", "PGB-DO", "CIE-DO", "CIB-DO", "FBE-DO", "FBB-DO") #Rename columns
DOData$Date <- as.Date(DOData$Date, format = "%m/%d/%y") #Convert entries to dates
DOData <- DOData[DOData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
DOData$DateTime <- paste(DOData$Date, DOData$Time) #Create new DateTime column to easily merge tide and environmental data
head(DOData) #Confirm changes
salinityData <- read.csv("../../../../data/DNR/2018-05-30-Fixed-Salinity-from-Micah.csv", header = TRUE, na.strings = "NA", strip.white = TRUE) #Import salinity data and remove white space from end of Date and Time columns
salinityData <- salinityData[,c(1:2, 4, 6, 8, 10, 12, 14, 16, 20)] #Subset salinity from bare and eelgrass outplants. Needed to use PGE instead of PGB since PGB has no salinity data. Also use FBE and WBE due to probe burial at bare sites.
head(salinityData) #Confirm subset
colnames(salinityData) <- c("Date", "Time", "CIB-Salinity", "CIE-Salinity", "FBB-Salinity", "FBE-Salinity", "PGE-Salinity", "SKB-Salinity", "SKE-Salinity", "WBB-Salinity") #Rename columns
salinityData$Date <- as.Date(salinityData$Date, format = "%d/%m/%Y") #Convert entries to dates
salinityData <- salinityData[salinityData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
salinityData$DateTime <- paste(salinityData$Date, salinityData$Time) #Create new DateTime column to easily merge tide and environmental data.
head(salinityData)
temperatureData <- read.csv("../../../../data/DNR/2017-11-14-Environmental-Data-from-Micah.csv", header = TRUE, na.strings = "NA") #Import temperature data
colnames(temperatureData) #Get column names
temperatureData <- temperatureData[,c(2:3, 32:41)] #Save temperature data from bare outplants as a new dataframe
head(temperatureData) #Confirm subset
colnames(temperatureData) <- c("Date", "Time", "WBE", "WBB", "SKE", "SKB", "PGE", "PGB", "CIE", "CIB", "FBE", "FBB") #Rename columns
temperatureData$Date <- as.Date(temperatureData$Date, format = "%m/%d/%y") #Convert entries to dates
temperatureData <- temperatureData[temperatureData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
temperatureData$DateTime <- paste(temperatureData$Date, temperatureData$Time) #Create new DateTime column to easily merge tide and environmental data
head(temperatureData) #Confirm changes
temperatureData <- temperatureData[-c(4897:4898), ] #Remove blank two rows at the end of the data
tail(temperatureData) #Confirm changes
pHTideData <- merge(x = pHData, y = tideData, by = "DateTime") #Merge pH and tide data
colnames(pHTideData) #Get column names
pHTideData <- pHTideData[, -c(13:14)] #Remove redundant date and time columns
colnames(pHTideData) <- c("DateTime", "Date", "Time", "WBE-pH", "WBB-pH", "SKE-pH", "SKB-pH", "PGB-pH", "CIE-pH", "CIB-pH", "FBE-pH", "FBB-pH", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(pHTideData) #Confirm changes
DOTideData <- merge(x = DOData, y = tideData, by = "DateTime") #Merge DO and tide data
colnames(DOTideData) #Get column names
DOTideData <- DOTideData[, -c(14:15)] #Remove redundant date and time columns
colnames(DOTideData) <- c("DateTime", "Date", "Time", "WBE-DO", "WBB-DO", "SKE-DO", "SKB-DO", "PGE-DO", "PGB-DO", "CIE-DO", "CIB-DO", "FBE-DO", "FBB-DO", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(DOTideData) #Confirm changes
salinityTideData <- merge(x = salinityData, y = tideData, by = "DateTime") #Merge salinity and tide data
colnames(salinityTideData) #Get column names
salinityTideData <- salinityTideData[, -c(12:13)] #Remove redundant date and time columns
colnames(salinityTideData) <- c("DateTime", "Date", "Time", "CIB-Salinity", "CIE-Salinity", "FBB-Salinity", "FBE-Salinity", "PGE-Salinity", "SKB-Salinity", "SKE-Salinity", "WBB-Salinity", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(salinityTideData) #Confirm changes
colnames(pHTideData)
pHTideData$`WBE-pH`[pHTideData$`WB-Tide` <= 1] <- NA #Replace WBE-pH values with "NA" when tide is less than 1
pHTideData$`WBB-pH`[pHTideData$`WB-Tide` <= 1] <- NA #Replace WBB-pH values with "NA" when tide is less than 1
pHTideData$`SKE-pH`[pHTideData$`SK-Tide` <= 1] <- NA #Replace SKE-pH values with "NA" when tide is less than 1
pHTideData$`SKB-pH`[pHTideData$`SK-Tide` <= 1] <- NA #Replace SKB-pH values with "NA" when tide is less than 1
pHTideData$`PGB-pH`[pHTideData$`PG-Tide` <= 1] <- NA #Replace PGB-pH values with "NA" when tide is less than 1
pHTideData$`CIE-pH`[pHTideData$`CI-Tide` <= 1] <- NA #Replace CIE-pH values with "NA" when tide is less than 1
pHTideData$`CIB-pH`[pHTideData$`CI-Tide` <= 1] <- NA #Replace CIB-pH values with "NA" when tide is less than 1
pHTideData$`FBE-pH`[pHTideData$`FB-Tide` <= 1] <- NA #Replace FBE-pH values with "NA" when tide is less than 1
pHTideData$`FBB-pH`[pHTideData$`FB-Tide` <= 1] <- NA #Replace FBB-pH values with "NA" when tide is less than 1
#Convert to numeric values
pHTideData$`WBE-pH` <- as.numeric(pHTideData$`WBE-pH`)
pHTideData$`WBB-pH` <- as.numeric(pHTideData$`WBB-pH`)
pHTideData$`SKE-pH` <- as.numeric(pHTideData$`SKE-pH`)
pHTideData$`SKB-pH` <- as.numeric(pHTideData$`SKB-pH`)
pHTideData$`PGB-pH` <- as.numeric(pHTideData$`PGB-pH`)
pHTideData$`CIE-pH` <- as.numeric(pHTideData$`CIE-pH`)
pHTideData$`CIB-pH` <- as.numeric(pHTideData$`CIB-pH`)
pHTideData$`FBE-pH` <- as.numeric(pHTideData$`FBE-pH`)
pHTideData$`FBB-pH` <- as.numeric(pHTideData$`FBB-pH`)
colnames(DOTideData)
DOTideData$`WBE-DO`[DOTideData$`WB-Tide` <= 1] <- NA #Replace WBE-DO values with "NA" when tide is less than 1
DOTideData$`WBB-DO`[DOTideData$`WB-Tide` <= 1] <- NA #Replace WBB-DO values with "NA" when tide is less than 1
DOTideData$`SKE-DO`[DOTideData$`SK-Tide` <= 1] <- NA #Replace SKE-DO values with "NA" when tide is less than 1
DOTideData$`SKB-DO`[DOTideData$`SK-Tide` <= 1] <- NA #Replace SKB-DO values with "NA" when tide is less than 1
DOTideData$`PGE-DO`[DOTideData$`PG-Tide` <= 1] <- NA #Replace PGE-DO values with "NA" when tide is less than 1
DOTideData$`PGB-DO`[DOTideData$`PG-Tide` <= 1] <- NA #Replace PGB-DO values with "NA" when tide is less than 1
DOTideData$`CIE-DO`[DOTideData$`CI-Tide` <= 1] <- NA #Replace CIE-DO values with "NA" when tide is less than 1
DOTideData$`CIB-DO`[DOTideData$`CI-Tide` <= 1] <- NA #Replace CIB-DO values with "NA" when tide is less than 1
DOTideData$`FBE-DO`[DOTideData$`FB-Tide` <= 1] <- NA #Replace FBE-DO values with "NA" when tide is less than 1
DOTideData$`FBB-DO`[DOTideData$`FB-Tide` <= 1] <- NA #Replace FBB-DO values with "NA" when tide is less than 1
#Convert to numeric values
DOTideData$`WBE-DO` <- as.numeric(DOTideData$`WBE-DO`)
DOTideData$`WBB-DO` <- as.numeric(DOTideData$`WBB-DO`)
DOTideData$`SKE-DO` <- as.numeric(DOTideData$`SKE-DO`)
DOTideData$`SKB-DO` <- as.numeric(DOTideData$`SKB-DO`)
DOTideData$`PGE-DO` <- as.numeric(DOTideData$`PGE-DO`)
DOTideData$`PGB-DO` <- as.numeric(DOTideData$`PGB-DO`)
DOTideData$`CIE-DO` <- as.numeric(DOTideData$`CIE-DO`)
DOTideData$`CIB-DO` <- as.numeric(DOTideData$`CIB-DO`)
DOTideData$`FBE-DO` <- as.numeric(DOTideData$`FBE-DO`)
DOTideData$`FBB-DO` <- as.numeric(DOTideData$`FBB-DO`)
colnames(salinityTideData)
salinityTideData$`CIB-Salinity`[salinityTideData$`CIB-Salinity` <= 1] <- NA #Replace CIB-Salinity values with "NA" when tide is less than 1
salinityTideData$`CIE-Salinity`[salinityTideData$`CIB-Salinity` <= 1] <- NA #Replace CIB-Salinity values with "NA" when tide is less than 1
salinityTideData$`FBB-Salinity`[salinityTideData$`FB-Salinity` <= 1] <- NA #Replace FBB-Salinity values with "NA" when tide is less than 1
salinityTideData$`FBE-Salinity`[salinityTideData$`FB-Salinity` <= 1] <- NA #Replace FBE-Salinity values with "NA" when tide is less than 1
salinityTideData$`PGE-Salinity`[salinityTideData$`PG-Salinity` <= 1] <- NA #Replace PGE-Salinity values with "NA" when tide is less than 1
salinityTideData$`SKB-Salinity`[salinityTideData$`SK-Salinity` <= 1] <- NA #Replace SKB-Salinity values with "NA" when tide is less than 1
salinityTideData$`SKE-Salinity`[salinityTideData$`SK-Salinity` <= 1] <- NA #Replace SKE-Salinity values with "NA" when tide is less than 1
salinityTideData$`WBB-Salinity`[salinityTideData$`WB-Salinity` <= 1] <- NA #Replace WBB-Salinity values with "NA" when tide is less than 1
#Convert to numeric values
salinityTideData$`CIB-Salinity` <- as.numeric(salinityTideData$`CIB-Salinity`)
salinityTideData$`CIE-Salinity` <- as.numeric(salinityTideData$`CIE-Salinity`)
salinityTideData$`FBB-Salinity` <- as.numeric(salinityTideData$`FBB-Salinity`)
salinityTideData$`FBE-Salinity` <- as.numeric(salinityTideData$`FBE-Salinity`)
salinityTideData$`PGE-Salinity` <- as.numeric(salinityTideData$`PGE-Salinity`)
salinityTideData$`SKB-Salinity` <- as.numeric(salinityTideData$`SKB-Salinity`)
salinityTideData$`SKE-Salinity` <- as.numeric(salinityTideData$`SKE-Salinity`)
salinityTideData$`WBB-Salinity` <- as.numeric(salinityTideData$`WBB-Salinity`)
nSites <- 17 #Sites are from columns 4 to 17
for(i in 4:nSites) { #For individual site-habitat data
upperBound <- as.numeric((quantile(pHTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(pHTideData[, i], na.rm = TRUE)[4] - quantile(pHTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
lowerBound <- as.numeric((quantile(pHTideData[, i], na.rm = TRUE)[2]) - (1.5*(quantile(pHTideData[, i], na.rm = TRUE)[4] - quantile(pHTideData[, i], na.rm = TRUE)[2]))) #Calculate lower bound
pHTideData[, i][pHTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
pHTideData[, i][pHTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
nSites <- 18 #Sites are from columns 4 to 18
for(i in 4:nSites) { #For individual site data
upperBound <- as.numeric((quantile(DOTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(DOTideData[, i], na.rm = TRUE)[4] - quantile(DOTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
lowerBound <- 0 #Dissolved oxygen content cannot be less than zero
DOTideData[, i][DOTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
DOTideData[, i][DOTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
nSites <- 16 #Sites are from columns 4 to 16
for(i in 4:nSites) { #For individual site data
upperBound <- as.numeric((quantile(salinityTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(salinityTideData[, i], na.rm = TRUE)[4] - quantile(salinityTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
lowerBound <- as.numeric((quantile(salinityTideData[, i], na.rm = TRUE)[2]) - (1.5*(quantile(salinityTideData[, i], na.rm = TRUE)[4] - quantile(salinityTideData[, i], na.rm = TRUE)[2]))) #Calculate lower bound
salinityTideData[, i][salinityTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
salinityTideData[, i][salinityTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
outplantDates <- as.Date(unique(temperatureData$Date)) #Save outplant dates as a new vector
outplantDates #Confirm vector creation
head(pHTideData)
pHMean <- data.frame("Date" = outplantDates,
"WBE-pH-mean" = rep(0, length(outplantDates)),
"WBB-pH-mean" = rep(0, length(outplantDates)),
"SKE-pH-mean" = rep(0, length(outplantDates)),
"SKB-pH-mean" = rep(0, length(outplantDates)),
"PGB-pH-mean" = rep(0, length(outplantDates)),
"CIE-pH-mean" = rep(0, length(outplantDates)),
"CIB-pH-mean" = rep(0, length(outplantDates)),
"FBE-pH-mean" = rep(0, length(outplantDates)),
"FBB-pH-mean"  = rep(0, length(outplantDates))) #Create an empty dataframe
head(pHMean)
nDates <- length(outplantDates)
for (j in 4:12) { #For each column with pH data
for(i in 1:nDates) { #For each date
pHMean[i, j-2] <- mean(pHTideData[pHTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(pHMean) <- sapply(pHMean, is.nan) #Replace all "NaN" with N/A
head(pHMean) #Confirm dataframe filling. All "NaN" values are now replaced with N/A.
pHVariance <- data.frame("Date" = outplantDates,
"WBE-pH-var" = rep(0, length(outplantDates)),
"WBB-pH-var" = rep(0, length(outplantDates)),
"SKE-pH-var" = rep(0, length(outplantDates)),
"SKB-pH-var" = rep(0, length(outplantDates)),
"PGB-pH-var" = rep(0, length(outplantDates)),
"CIE-pH-var" = rep(0, length(outplantDates)),
"CIB-pH-var" = rep(0, length(outplantDates)),
"FBE-pH-var" = rep(0, length(outplantDates)),
"FBB-pH-var"  = rep(0, length(outplantDates))) #Create an empty dataframe
head(pHVariance)
for (j in 4:12) { #For each column with pH data
for(i in 1:nDates) { #For each date
pHVariance[i, j-2] <- var(pHTideData[pHTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance  of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "N/A" in the dataframe.
head(pHVariance) #Confirm dataframe filling.
head(DOTideData)
DOMean <- data.frame("Date" = outplantDates,
"WBE-DO-mean" = rep(0, length(outplantDates)),
"WBB-DO-mean" = rep(0, length(outplantDates)),
"SKE-DP-mean" = rep(0, length(outplantDates)),
"SKB-DO-mean" = rep(0, length(outplantDates)),
"PGE-DO-mean" = rep(0, length(outplantDates)),
"PGB-DO-mean" = rep(0, length(outplantDates)),
"CIE-DO-mean" = rep(0, length(outplantDates)),
"CIB-DO-mean" = rep(0, length(outplantDates)),
"FBE-DO-mean" = rep(0, length(outplantDates)),
"FBB-DO-mean" = rep(0, length(outplantDates))) #Create an empty dataframe
head(DOMean)
for (j in 4:13) { #For each column with DO data
for(i in 1:nDates) { #For each date
DOMean[i, j-2] <- mean(DOTideData[DOTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(DOMean) <- sapply(DOMean, is.nan) #Replace all "NaN" with N/A
head(DOMean) #Confirm dataframe filling. All "Inf" values are now replaced
DOVariance <- data.frame("Date" = outplantDates,
"WBE-DO-var" = rep(0, length(outplantDates)),
"WBB-DO-var" = rep(0, length(outplantDates)),
"SKE-DP-var" = rep(0, length(outplantDates)),
"SKB-DO-var" = rep(0, length(outplantDates)),
"PGE-DO-var" = rep(0, length(outplantDates)),
"PGB-DO-var" = rep(0, length(outplantDates)),
"CIE-DO-var" = rep(0, length(outplantDates)),
"CIB-DO-var" = rep(0, length(outplantDates)),
"FBE-DO-var" = rep(0, length(outplantDates)),
"FBB-DO-var" = rep(0, length(outplantDates))) #Create an empty dataframe
head(DOVariance)
for (j in 4:13) { #For each column with DO data
for(i in 1:nDates) { #For each date
DOVariance[i, j-2] <- var(DOTideData[DOTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column.
head(DOVariance) #Confirm dataframe filling.
head(salinityTideData)
salinityMean <- data.frame("Date" = outplantDates,
"CIB-sal-mean" = rep(0, length(outplantDates)),
"CIE-sal-mean" = rep(0, length(outplantDates)),
"FBB-sal-mean" = rep(0, length(outplantDates)),
"FBE-sal-mean" = rep(0, length(outplantDates)),
"PGE-sal-mean" = rep(0, length(outplantDates)),
"SKB-sal-mean" = rep(0, length(outplantDates)),
"SKE-sal-mean" = rep(0, length(outplantDates)),
"WBB-sal-mean" = rep(0, length(outplantDates))) #Create an empty dataframe
head(salinityMean)
for (j in 4:11) { #For each column with salinity data
for(i in 1:nDates) { #For each date
salinityMean[i, j-2] <- mean(salinityTideData[salinityTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(salinityMean) <- sapply(salinityMean, is.nan) #Replace all "NaN" with N/A
head(salinityMean) #Confirm dataframe filling. All "NaN" values are now replaced
salinityVariance <- data.frame("Date" = outplantDates,
"CIB-sal-var" = rep(0, length(outplantDates)),
"CIE-sal-var" = rep(0, length(outplantDates)),
"FBB-sal-var" = rep(0, length(outplantDates)),
"FBE-sal-var" = rep(0, length(outplantDates)),
"PGE-sal-var" = rep(0, length(outplantDates)),
"SKB-sal-var" = rep(0, length(outplantDates)),
"SKE-sal-var" = rep(0, length(outplantDates)),
"WBB-sal-var" = rep(0, length(outplantDates))) #Create an empty dataframe
head(salinityVariance)
for (j in 4:11) { #For each column with salinity data
for(i in 1:nDates) { #For each date
salinityVariance[i, j-2] <- var(salinityTideData[salinityTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as N/A in the dataframe.
head(salinityVariance) #Confirm dataframe filling.
head(temperatureData)
outplantDateCharacters <- as.character(outplantDates) #Convert outplant dates to characters
temperatureData$DateCharacters <- as.character(temperatureData$Date) #Convert dates to characters
temperatureMean <- data.frame("Date" = outplantDateCharacters,
"WBE-temp-mean" = rep(0, length(outplantDates)),
"WBB-temp-mean" = rep(0, length(outplantDates)),
"SKE-temp-mean" = rep(0, length(outplantDates)),
"SKB-temp-mean" = rep(0, length(outplantDates)),
"PGE-temp-mean" = rep(0, length(outplantDates)),
"PGB-temp-mean" = rep(0, length(outplantDates)),
"CIE-temp-mean" = rep(0, length(outplantDates)),
"CIB-temp-mean" = rep(0, length(outplantDates)),
"FBE-temp-mean" = rep(0, length(outplantDates)),
"FBB-temp-mean" = rep(0, length(outplantDates))) #Create an empty dataframe, but be sure to use outplantDateCharacters
head(temperatureMean)
for (j in 3:12) { #For each column with temperature data
for(i in 1:nDates) { #For each date
temperatureMean[i, j-1] <- mean(temperatureData[temperatureData$DateCharacters == outplantDateCharacters[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "Inf" in the dataframe.
is.na(temperatureMean) <- sapply(temperatureMean, is.nan) #Replace all "NaN" with N/A
head(temperatureMean) #Confirm dataframe filling. All "NaN" values are now replaced
temperatureMean$Date <- outplantDates #Replace temperatureMean$Date with outplantDates so they are dates
head(temperatureMean)
temperatureVariance <- data.frame("Date" = outplantDateCharacters,
"WBE-temp-var" = rep(0, length(outplantDates)),
"WBB-temp-var" = rep(0, length(outplantDates)),
"SKE-temp-var" = rep(0, length(outplantDates)),
"SKB-temp-var" = rep(0, length(outplantDates)),
"PGE-temp-var" = rep(0, length(outplantDates)),
"PGB-temp-var" = rep(0, length(outplantDates)),
"CIE-temp-var" = rep(0, length(outplantDates)),
"CIB-temp-var" = rep(0, length(outplantDates)),
"FBE-temp-var" = rep(0, length(outplantDates)),
"FBB-temp-var" = rep(0, length(outplantDates))) #Create an empty dataframe, but be sure to use outplantDateCharacters
head(temperatureVariance)
for (j in 3:12) { #For each column with temperature data
for(i in 1:nDates) { #For each date
temperatureVariance[i, j-1] <- var(temperatureData[temperatureData$DateCharacters == outplantDateCharacters[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
}
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "Inf" in the dataframe.
head(temperatureVariance) #Confirm dataframe filling. All "Inf" values are now replaced
temperatureVariance$Date <- outplantDates #Replace temperatureVariance$Date with outplantDates so they are dates
head(temperatureVariance)
dailyEnvironmentalData <- cbind(pHMean, pHVariance,
DOMean, DOVariance,
salinityMean, salinityVariance,
temperatureMean, temperatureVariance) #Use cbind to merge all of the dataframes together
colnames(dailyEnvironmentalData) #View column names
dailyEnvironmentalData <- dailyEnvironmentalData[-c(11, 21, 32, 43, 52, 61, 72)] #Remove all redundant "Date" columns
colnames(dailyEnvironmentalData) #Confirm column removal
dailyEnvironmentalDataCorrected <- dailyEnvironmentalData #Duplicate dataframe
rownames(dailyEnvironmentalDataCorrected) <- dailyEnvironmentalDataCorrected$Date #Save dates as rownames
dailyEnvironmentalDataCorrected <- dailyEnvironmentalDataCorrected[, -1] #Remove date column
head(dailyEnvironmentalDataCorrected) #Confirm changes
envData.log <- log(dailyEnvironmentalDataCorrected + 1) #Log transform data before analysis
#envData.log[is.na(envData.log)] <- 0 #Replace NAs with 0s
head(envData.log) #View transformation
nmds.scree(envData.log, distance = "gower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
nmds.scree(envData.log, distance = "altGower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
nmds.scree(envData.log, distance = "gower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
#envData.log[is.na(envData.log)] <- 0 #Replace NAs with 0s
envData.log.trans <- t(envData.log) #Transpose dataframe so objects are environmental conditions at site-habitat combinations, and descriptors are dates
head(envData.log.trans) #View transformation
envData.log <- log(dailyEnvironmentalDataCorrected + 1) #Log transform data before analysis
#envData.log[is.na(envData.log)] <- 0 #Replace NAs with 0s
envData.log <- envData.log[-c(32:34),] #Remove last three rows since the outplant ended before then
tail(envData.log)
envData.log.trans <- t(envData.log) #Transpose dataframe so objects are environmental conditions at site-habitat combinations, and descriptors are dates
head(envData.log.trans) #View transformation
nmds.scree(envData.log.trans, distance = "gower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
rownames(envData.log.trans)
rownames(envData.log.trans == "WB")
grep(rownames(envData.log.trans), "WB")
grep(rownames(envData.log.trans), pattern = "WB")
envData.log.trans[grep(rownames(envData.log.trans), pattern = "WB")]
envData.log.trans[grep(rownames(envData.log.trans), pattern = "WB"),]
head(envData.log.trans) #View transformation
length(envData.log.trans)
length(envData.log.trans[1])
length(envData.log.trans[1],)
envData.log.trans <- data.frame(t(envData.log)) #Transpose dataframe so objects are environmental conditions at site-habitat combinations, and descriptors are dates. This is the data I will use for the NMDS.
head(envData.log.trans) #View transformation
nmds.scree(envData.log.trans, distance = "gower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
envData.log.trans[grep(rownames(envData.log.trans), pattern = "WB"),]
plotCustomization <- data.frame("Site" = rep(0, times = length(envData.log.trans$X2016.06.19)),
"Habitat" = rep(0, times = length(envData.log.trans$X2016.06.19)),
"Site-Habitat" = rep(0, times = length(envData.log.trans$X2016.06.19)),
"Shape" = rep(0, times = length(envData.log.trans$X2016.06.19)),
"Color" = rep(0, times = length(envData.log.trans$X2016.06.19))) #Create a new dataframe to store plot customization information
colnames(envData.log.trans) <- rownames(envData.log)
head(envData.log.trans)
plotCustomization <- data.frame("Site" = rep(0, times = length(envData.log.trans$2016.06.19)),
plotCustomization <- data.frame("Site" = rep(0, times = length(envData.log.trans$`2016-06-19`)),
"Habitat" = rep(0, times = length(envData.log.trans$`2016-06-19`)),
"Site-Habitat" = rep(0, times = length(envData.log.trans$`2016-06-19`)),
"Shape" = rep(0, times = length(envData.log.trans$`2016-06-19`)),
"Color" = rep(0, times = length(envData.log.trans$`2016-06-19`))) #Create a new dataframe to store plot customization information
head(plotCustomization) #Confirm creation
rownames(plotCustomization) <- rownames(envData.log.trans) #Use rownames from NMDS data as rownames for the customization information
head(plotCustomization) #Confirm creation
plotCustomization[grep(rownames(plotCustomization), pattern = "WB"),]
plotCustomization[grep(rownames(plotCustomization), pattern = "WB"), "Site"]
plotCustomization[grep(rownames(plotCustomization), pattern = "CI"), "Site"] <- "CI"
head(plotCustomization)
plotCustomization[grep(rownames(plotCustomization), pattern = "FB"), "Site"] <- "FB" #For each rowname with "FB", add "FB" to the site column
plotCustomization[grep(rownames(plotCustomization), pattern = "PG"), "Site"] <- "PG" #For each rowname with "PG", add "PG" to the site column
plotCustomization[grep(rownames(plotCustomization), pattern = "SK"), "Site"] <- "SK" #For each rowname with "SK", add "SK" to the site column
plotCustomization[grep(rownames(plotCustomization), pattern = "WB"), "Site"] <- "WB" #For each rowname with "WB", add "WB" to the site column
head(plotCustomization) #Confirm changes
plotCustomization[grep(rownames(plotCustomization), pattern = "B"),]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB" | "FIB"),]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB" | "FIB") ,]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB") ,]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB", "FIB") ,]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB"), "Habitat"]
plotCustomization[grep(rownames(plotCustomization), pattern = "CIB"), "Habitat"] <- "Bare"
plotCustomization[grep(rownames(plotCustomization), pattern = "FBB"), "Habitat"] <- "Bare" #For each rowname with "FBB", add "Bare" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "PGB"), "Habitat"] <- "Bare" #For each rowname with "PGB", add "Bare" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "SKB"), "Habitat"] <- "Bare" #For each rowname with "SKB", add "Bare" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "WBB"), "Habitat"] <- "Bare" #For each rowname with "WBB", add "Bare" to the habitat column
head(plotCustomization) #Confirm changes
plotCustomization[grep(rownames(plotCustomization), pattern = "CIE"), "Habitat"] <- "Eelgrass" #For each rowname with "CIE", add "Eelgrass" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "FBE"), "Habitat"] <- "Eelgrass" #For each rowname with "FBE", add "Eelgrass" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "PGE"), "Habitat"] <- "Eelgrass" #For each rowname with "PGE", add "Eelgrass" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "SKE"), "Habitat"] <- "Eelgrass" #For each rowname with "SKE", add "Eelgrass" to the habitat column
plotCustomization[grep(rownames(plotCustomization), pattern = "WBE"), "Habitat"] <- "Eelgrass" #For each rowname with "WBE", add "Eelgrass" to the habitat column
head(plotCustomization) #Confirm changes
plotCustomization$Site.Habitat <- paste(plotCustomization$Site, "", plotCustomization$Habitat)
head(plotCustomization) #Confirm changes
plotCustomization$Site.Habitat <- paste(plotCustomization$Site, "-", plotCustomization$Habitat)
head(plotCustomization) #Confirm changes
plotCustomization$Site.Habitat <- paste(plotCustomization$Site, "", plotCustomization$Habitat)
head(plotCustomization) #Confirm changes
head(plotCustomization) #Confirm changes
plotCustomization[grep(plotCustomization$Habitat, pattern = "Eelgrass"), "Shape"] <- 3 #Add 3to the Shape column for each instance of "Eelgrass" in the Habitat column
plotCustomization[grep(plotCustomization$Habitat, pattern = "Bare"), "Shape"] <- 4 #Add 3to the Shape column for each instance of "Bare" in the Habitat column
head(plotCustomization)
plotCustomization[grep(plotCustomization$Site, pattern = "CI"), "Color"] <- "red" #Add "red" to the Color column for each instance of "CI" in the Site column
plotCustomization[grep(plotCustomization$Site, pattern = "FB"), "Color"] <- "blue" #Add "blue" to the Color column for each instance of "FB" in the Site column
plotCustomization[grep(plotCustomization$Site, pattern = "PG"), "Color"] <- "magenta" #Add "magenta" to the Color column for each instance of "PG" in the Site column
plotCustomization[grep(plotCustomization$Site, pattern = "SK"), "Color"] <- "green" #Add "green" to the Color column for each instance of "SK" in the Site column
plotCustomization[grep(plotCustomization$Site, pattern = "WB"), "Color"] <- "black" #Add "black" to the Color column for each instance of "WB" in the Site column
head(plotCustomization) #Confirm changes
