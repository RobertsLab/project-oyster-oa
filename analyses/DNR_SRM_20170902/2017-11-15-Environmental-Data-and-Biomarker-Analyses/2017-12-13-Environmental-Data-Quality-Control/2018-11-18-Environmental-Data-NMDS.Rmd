---
title: "Environmental Data NMDS"
author: "Yaamini Venkataraman"
date: "11/18/2018"
output: html_document
---

In this script, I'll visualize differences in my environmental data between sites using a nonmetric multidimensional scaling (NMDS) and analysis of similarities (ANOSIM).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load dependencies

```{r}
#install.packages("vegan")
require(vegan)
#install.packages("cluster")
require(cluster)

source("../../biostats.R") #Load biostats file
```

```{r}
sessionInfo()
```

# Import and reformat data

## Tide data

```{r}
tideData <- read.csv("../../../../data/DNR/2017-12-13-Tidal-Data-by-Site.csv", header = TRUE, strip.white = TRUE) #Import the tide data
tideData$Date <- as.Date(tideData$Date, format = "%m/%d/%y") #Convert entries to dates
tideData$DateTime <- paste(tideData$Date, tideData$Time) #Create new DateTime column to easily merge tide and environmental data
colnames(tideData) <- c("Date", "Time", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide", "DateTime")
head(tideData) #Confirm changes
```

## pH data

```{r}
pHDOData <- read.csv("../../../../data/DNR/2017-11-14-Environmental-Data-from-Micah.csv", header = TRUE, na.strings = "NA") #Import file with pH and DO data
colnames(pHDOData) #View column names
```

```{r}
pHData <- pHDOData[,c(2:3, 4:12)] #Subset only the bare and eelgrass outplant pH data
head(pHData) #Confirm subset
```

```{r}
colnames(pHData) <- c("Date", "Time", "WBE-pH", "WBB-pH", "SKE-pH", "SKB-pH", "PGB-pH", "CIE-pH", "CIB-pH", "FBE-pH", "FBB-pH") #Rename columns
pHData$Date <- as.Date(pHData$Date, format = "%m/%d/%y") #Convert entries to dates
pHData <- pHData[pHData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
pHData$DateTime <- paste(pHData$Date, pHData$Time) #Create new DateTime column to easily merge tide and environmental data
head(pHData) #Confirm changes
```

## Dissolved oxygen data

```{r}
DOData <- pHDOData[,c(2:3, 22:31)] #Subset the bare and eelgrass outplant DO data
head(DOData) #Confirm subset
```

```{r}
colnames(DOData) <- c("Date", "Time", "WBE-DO", "WBB-DO", "SKE-DO", "SKB-DO", "PGE-DO", "PGB-DO", "CIE-DO", "CIB-DO", "FBE-DO", "FBB-DO") #Rename columns
DOData$Date <- as.Date(DOData$Date, format = "%m/%d/%y") #Convert entries to dates
DOData <- DOData[DOData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
DOData$DateTime <- paste(DOData$Date, DOData$Time) #Create new DateTime column to easily merge tide and environmental data
head(DOData) #Confirm changes
```

## Salinity

```{r}
salinityData <- read.csv("../../../../data/DNR/2018-05-30-Fixed-Salinity-from-Micah.csv", header = TRUE, na.strings = "NA", strip.white = TRUE) #Import salinity data and remove white space from end of Date and Time columns
salinityData <- salinityData[,c(1:2, 4, 6, 8, 10, 12, 14, 16, 20)] #Subset salinity from bare and eelgrass outplants. Needed to use PGE instead of PGB since PGB has no salinity data. Also use FBE and WBE due to probe burial at bare sites.
head(salinityData) #Confirm subset
```

```{r}
colnames(salinityData) <- c("Date", "Time", "CIB-Salinity", "CIE-Salinity", "FBB-Salinity", "FBE-Salinity", "PGE-Salinity", "SKB-Salinity", "SKE-Salinity", "WBB-Salinity") #Rename columns
salinityData$Date <- as.Date(salinityData$Date, format = "%d/%m/%Y") #Convert entries to dates
salinityData <- salinityData[salinityData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
salinityData$DateTime <- paste(salinityData$Date, salinityData$Time) #Create new DateTime column to easily merge tide and environmental data.
head(salinityData)
```

## Temperature data

```{r}
temperatureData <- read.csv("../../../../data/DNR/2017-11-14-Environmental-Data-from-Micah.csv", header = TRUE, na.strings = "NA") #Import temperature data
colnames(temperatureData) #Get column names
```

```{r}
temperatureData <- temperatureData[,c(2:3, 32:41)] #Save temperature data from bare outplants as a new dataframe
head(temperatureData) #Confirm subset
```

```{r}
colnames(temperatureData) <- c("Date", "Time", "WBE", "WBB", "SKE", "SKB", "PGE", "PGB", "CIE", "CIB", "FBE", "FBB") #Rename columns
temperatureData$Date <- as.Date(temperatureData$Date, format = "%m/%d/%y") #Convert entries to dates
temperatureData <- temperatureData[temperatureData$Date >= "2016-06-19", ] #The outplant only started 6/19. I need to remove all data points before this time.
temperatureData$DateTime <- paste(temperatureData$Date, temperatureData$Time) #Create new DateTime column to easily merge tide and environmental data
head(temperatureData) #Confirm changes
```

```{r}
temperatureData <- temperatureData[-c(4897:4898), ] #Remove blank two rows at the end of the data
tail(temperatureData) #Confirm changes
```

# Merge tidal data with environmental data

Tide correction only needs to occur for pH, dissolved oxygen, and salinity data. Temperature data from low tide conditions is still an accurate representation of the oysters' environment.

## pH data

```{r}
pHTideData <- merge(x = pHData, y = tideData, by = "DateTime") #Merge pH and tide data
colnames(pHTideData) #Get column names
```

```{r}
pHTideData <- pHTideData[, -c(13:14)] #Remove redundant date and time columns
colnames(pHTideData) <- c("DateTime", "Date", "Time", "WBE-pH", "WBB-pH", "SKE-pH", "SKB-pH", "PGB-pH", "CIE-pH", "CIB-pH", "FBE-pH", "FBB-pH", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(pHTideData) #Confirm changes
```

## Dissolved oxygen 

```{r}
DOTideData <- merge(x = DOData, y = tideData, by = "DateTime") #Merge DO and tide data
colnames(DOTideData) #Get column names
```

```{r}
DOTideData <- DOTideData[, -c(14:15)] #Remove redundant date and time columns
colnames(DOTideData) <- c("DateTime", "Date", "Time", "WBE-DO", "WBB-DO", "SKE-DO", "SKB-DO", "PGE-DO", "PGB-DO", "CIE-DO", "CIB-DO", "FBE-DO", "FBB-DO", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(DOTideData) #Confirm changes
```

## Salinity

```{r}
salinityTideData <- merge(x = salinityData, y = tideData, by = "DateTime") #Merge salinity and tide data
colnames(salinityTideData) #Get column names
```

```{r}
salinityTideData <- salinityTideData[, -c(12:13)] #Remove redundant date and time columns
colnames(salinityTideData) <- c("DateTime", "Date", "Time", "CIB-Salinity", "CIE-Salinity", "FBB-Salinity", "FBE-Salinity", "PGE-Salinity", "SKB-Salinity", "SKE-Salinity", "WBB-Salinity", "CI-Tide", "FB-Tide", "PG-Tide", "SK-Tide", "WB-Tide") #Change column names
head(salinityTideData) #Confirm changes
```

# Remove exposure times

## pH

```{r}
colnames(pHTideData)
```


```{r}
pHTideData$`WBE-pH`[pHTideData$`WB-Tide` <= 1] <- NA #Replace WBE-pH values with "NA" when tide is less than 1
pHTideData$`WBB-pH`[pHTideData$`WB-Tide` <= 1] <- NA #Replace WBB-pH values with "NA" when tide is less than 1

pHTideData$`SKE-pH`[pHTideData$`SK-Tide` <= 1] <- NA #Replace SKE-pH values with "NA" when tide is less than 1
pHTideData$`SKB-pH`[pHTideData$`SK-Tide` <= 1] <- NA #Replace SKB-pH values with "NA" when tide is less than 1

pHTideData$`PGB-pH`[pHTideData$`PG-Tide` <= 1] <- NA #Replace PGB-pH values with "NA" when tide is less than 1

pHTideData$`CIE-pH`[pHTideData$`CI-Tide` <= 1] <- NA #Replace CIE-pH values with "NA" when tide is less than 1
pHTideData$`CIB-pH`[pHTideData$`CI-Tide` <= 1] <- NA #Replace CIB-pH values with "NA" when tide is less than 1

pHTideData$`FBE-pH`[pHTideData$`FB-Tide` <= 1] <- NA #Replace FBE-pH values with "NA" when tide is less than 1
pHTideData$`FBB-pH`[pHTideData$`FB-Tide` <= 1] <- NA #Replace FBB-pH values with "NA" when tide is less than 1
```

```{r}
#Convert to numeric values

pHTideData$`WBE-pH` <- as.numeric(pHTideData$`WBE-pH`)
pHTideData$`WBB-pH` <- as.numeric(pHTideData$`WBB-pH`)

pHTideData$`SKE-pH` <- as.numeric(pHTideData$`SKE-pH`)
pHTideData$`SKB-pH` <- as.numeric(pHTideData$`SKB-pH`)

pHTideData$`PGB-pH` <- as.numeric(pHTideData$`PGB-pH`)

pHTideData$`CIE-pH` <- as.numeric(pHTideData$`CIE-pH`)
pHTideData$`CIB-pH` <- as.numeric(pHTideData$`CIB-pH`)

pHTideData$`FBE-pH` <- as.numeric(pHTideData$`FBE-pH`)
pHTideData$`FBB-pH` <- as.numeric(pHTideData$`FBB-pH`)
```

## Dissolved oxygen

```{r}
colnames(DOTideData)
```


```{r}
DOTideData$`WBE-DO`[DOTideData$`WB-Tide` <= 1] <- NA #Replace WBE-DO values with "NA" when tide is less than 1
DOTideData$`WBB-DO`[DOTideData$`WB-Tide` <= 1] <- NA #Replace WBB-DO values with "NA" when tide is less than 1

DOTideData$`SKE-DO`[DOTideData$`SK-Tide` <= 1] <- NA #Replace SKE-DO values with "NA" when tide is less than 1
DOTideData$`SKB-DO`[DOTideData$`SK-Tide` <= 1] <- NA #Replace SKB-DO values with "NA" when tide is less than 1

DOTideData$`PGE-DO`[DOTideData$`PG-Tide` <= 1] <- NA #Replace PGE-DO values with "NA" when tide is less than 1
DOTideData$`PGB-DO`[DOTideData$`PG-Tide` <= 1] <- NA #Replace PGB-DO values with "NA" when tide is less than 1

DOTideData$`CIE-DO`[DOTideData$`CI-Tide` <= 1] <- NA #Replace CIE-DO values with "NA" when tide is less than 1
DOTideData$`CIB-DO`[DOTideData$`CI-Tide` <= 1] <- NA #Replace CIB-DO values with "NA" when tide is less than 1

DOTideData$`FBE-DO`[DOTideData$`FB-Tide` <= 1] <- NA #Replace FBE-DO values with "NA" when tide is less than 1
DOTideData$`FBB-DO`[DOTideData$`FB-Tide` <= 1] <- NA #Replace FBB-DO values with "NA" when tide is less than 1
```

```{r}
#Convert to numeric values

DOTideData$`WBE-DO` <- as.numeric(DOTideData$`WBE-DO`)
DOTideData$`WBB-DO` <- as.numeric(DOTideData$`WBB-DO`)

DOTideData$`SKE-DO` <- as.numeric(DOTideData$`SKE-DO`)
DOTideData$`SKB-DO` <- as.numeric(DOTideData$`SKB-DO`)

DOTideData$`PGE-DO` <- as.numeric(DOTideData$`PGE-DO`)
DOTideData$`PGB-DO` <- as.numeric(DOTideData$`PGB-DO`)

DOTideData$`CIE-DO` <- as.numeric(DOTideData$`CIE-DO`)
DOTideData$`CIB-DO` <- as.numeric(DOTideData$`CIB-DO`)

DOTideData$`FBE-DO` <- as.numeric(DOTideData$`FBE-DO`)
DOTideData$`FBB-DO` <- as.numeric(DOTideData$`FBB-DO`)
```

## Salinity

```{r}
colnames(salinityTideData)
```

```{r}
salinityTideData$`CIB-Salinity`[salinityTideData$`CIB-Salinity` <= 1] <- NA #Replace CIB-Salinity values with "NA" when tide is less than 1
salinityTideData$`CIE-Salinity`[salinityTideData$`CIB-Salinity` <= 1] <- NA #Replace CIB-Salinity values with "NA" when tide is less than 1

salinityTideData$`FBB-Salinity`[salinityTideData$`FB-Salinity` <= 1] <- NA #Replace FBB-Salinity values with "NA" when tide is less than 1
salinityTideData$`FBE-Salinity`[salinityTideData$`FB-Salinity` <= 1] <- NA #Replace FBE-Salinity values with "NA" when tide is less than 1

salinityTideData$`PGE-Salinity`[salinityTideData$`PG-Salinity` <= 1] <- NA #Replace PGE-Salinity values with "NA" when tide is less than 1

salinityTideData$`SKB-Salinity`[salinityTideData$`SK-Salinity` <= 1] <- NA #Replace SKB-Salinity values with "NA" when tide is less than 1
salinityTideData$`SKE-Salinity`[salinityTideData$`SK-Salinity` <= 1] <- NA #Replace SKE-Salinity values with "NA" when tide is less than 1

salinityTideData$`WBB-Salinity`[salinityTideData$`WB-Salinity` <= 1] <- NA #Replace WBB-Salinity values with "NA" when tide is less than 1
```

```{r}
#Convert to numeric values
salinityTideData$`CIB-Salinity` <- as.numeric(salinityTideData$`CIB-Salinity`)
salinityTideData$`CIE-Salinity` <- as.numeric(salinityTideData$`CIE-Salinity`)

salinityTideData$`FBB-Salinity` <- as.numeric(salinityTideData$`FBB-Salinity`)
salinityTideData$`FBE-Salinity` <- as.numeric(salinityTideData$`FBE-Salinity`)

salinityTideData$`PGE-Salinity` <- as.numeric(salinityTideData$`PGE-Salinity`)

salinityTideData$`SKB-Salinity` <- as.numeric(salinityTideData$`SKB-Salinity`)
salinityTideData$`SKE-Salinity` <- as.numeric(salinityTideData$`SKE-Salinity`)

salinityTideData$`WBB-Salinity` <- as.numeric(salinityTideData$`WBB-Salinity`)
```

# Remove outliers

## pH

```{r}
nSites <- 17 #Sites are from columns 4 to 17
for(i in 4:nSites) { #For individual site-habitat data
  upperBound <- as.numeric((quantile(pHTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(pHTideData[, i], na.rm = TRUE)[4] - quantile(pHTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
  lowerBound <- as.numeric((quantile(pHTideData[, i], na.rm = TRUE)[2]) - (1.5*(quantile(pHTideData[, i], na.rm = TRUE)[4] - quantile(pHTideData[, i], na.rm = TRUE)[2]))) #Calculate lower bound
  pHTideData[, i][pHTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
  pHTideData[, i][pHTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
```

## Dissolved oxygen

```{r}
nSites <- 18 #Sites are from columns 4 to 18
for(i in 4:nSites) { #For individual site data
  upperBound <- as.numeric((quantile(DOTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(DOTideData[, i], na.rm = TRUE)[4] - quantile(DOTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
  lowerBound <- 0 #Dissolved oxygen content cannot be less than zero
  DOTideData[, i][DOTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
  DOTideData[, i][DOTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
```

## Salinity

```{r}
nSites <- 16 #Sites are from columns 4 to 16
for(i in 4:nSites) { #For individual site data
  upperBound <- as.numeric((quantile(salinityTideData[, i], na.rm = TRUE)[4]) + (1.5*(quantile(salinityTideData[, i], na.rm = TRUE)[4] - quantile(salinityTideData[, i], na.rm = TRUE)[2]))) #Calculate upper bound
  lowerBound <- as.numeric((quantile(salinityTideData[, i], na.rm = TRUE)[2]) - (1.5*(quantile(salinityTideData[, i], na.rm = TRUE)[4] - quantile(salinityTideData[, i], na.rm = TRUE)[2]))) #Calculate lower bound
  salinityTideData[, i][salinityTideData[, i] > upperBound] <- NA #Replace any values higher than upper bound with NA
  salinityTideData[, i][salinityTideData[, i] < lowerBound] <- NA #Replace any values lower than upper bound with NA
} #Replace outliers with NA values
```

# Obtain daily values for environmental data

Mean and variance values will be autocorrelated with maximum and minimum values, so I'll only calculate mean and variance.

```{r}
outplantDates <- as.Date(unique(temperatureData$Date)) #Save outplant dates as a new vector
outplantDates #Confirm vector creation
```

## pH

```{r}
head(pHTideData)
```

### Mean

```{r}
pHMean <- data.frame("Date" = outplantDates,
                     "WBE-pH-mean" = rep(0, length(outplantDates)),
                     "WBB-pH-mean" = rep(0, length(outplantDates)),
                     "SKE-pH-mean" = rep(0, length(outplantDates)),
                     "SKB-pH-mean" = rep(0, length(outplantDates)),
                     "PGB-pH-mean" = rep(0, length(outplantDates)),
                     "CIE-pH-mean" = rep(0, length(outplantDates)),
                     "CIB-pH-mean" = rep(0, length(outplantDates)),
                     "FBE-pH-mean" = rep(0, length(outplantDates)),
                     "FBB-pH-mean"  = rep(0, length(outplantDates))) #Create an empty dataframe
head(pHMean)
```

```{r}
nDates <- length(outplantDates)
for (j in 4:12) { #For each column with pH data
  for(i in 1:nDates) { #For each date
    pHMean[i, j-2] <- mean(pHTideData[pHTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(pHMean) <- sapply(pHMean, is.nan) #Replace all "NaN" with N/A
head(pHMean) #Confirm dataframe filling. All "NaN" values are now replaced with N/A.
```

### Variance

```{r}
pHVariance <- data.frame("Date" = outplantDates,
                        "WBE-pH-var" = rep(0, length(outplantDates)),
                        "WBB-pH-var" = rep(0, length(outplantDates)),
                        "SKE-pH-var" = rep(0, length(outplantDates)),
                        "SKB-pH-var" = rep(0, length(outplantDates)),
                        "PGB-pH-var" = rep(0, length(outplantDates)),
                        "CIE-pH-var" = rep(0, length(outplantDates)),
                        "CIB-pH-var" = rep(0, length(outplantDates)),
                        "FBE-pH-var" = rep(0, length(outplantDates)),
                        "FBB-pH-var"  = rep(0, length(outplantDates))) #Create an empty dataframe
head(pHVariance)
```

```{r}
for (j in 4:12) { #For each column with pH data
  for(i in 1:nDates) { #For each date
    pHVariance[i, j-2] <- var(pHTideData[pHTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance  of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "N/A" in the dataframe.
head(pHVariance) #Confirm dataframe filling.
```

## Dissolved oxygen

```{r}
head(DOTideData)
```

### Mean

```{r}
DOMean <- data.frame("Date" = outplantDates,
                        "WBE-DO-mean" = rep(0, length(outplantDates)),
                        "WBB-DO-mean" = rep(0, length(outplantDates)),
                        "SKE-DP-mean" = rep(0, length(outplantDates)),
                        "SKB-DO-mean" = rep(0, length(outplantDates)),
                        "PGE-DO-mean" = rep(0, length(outplantDates)),
                        "PGB-DO-mean" = rep(0, length(outplantDates)),
                        "CIE-DO-mean" = rep(0, length(outplantDates)),
                        "CIB-DO-mean" = rep(0, length(outplantDates)),
                        "FBE-DO-mean" = rep(0, length(outplantDates)),
                        "FBB-DO-mean" = rep(0, length(outplantDates))) #Create an empty dataframe
head(DOMean)
```

```{r}
for (j in 4:13) { #For each column with DO data
  for(i in 1:nDates) { #For each date
    DOMean[i, j-2] <- mean(DOTideData[DOTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(DOMean) <- sapply(DOMean, is.nan) #Replace all "NaN" with N/A
head(DOMean) #Confirm dataframe filling. All "Inf" values are now replaced
```

### Variance

```{r}
DOVariance <- data.frame("Date" = outplantDates,
                        "WBE-DO-var" = rep(0, length(outplantDates)),
                        "WBB-DO-var" = rep(0, length(outplantDates)),
                        "SKE-DP-var" = rep(0, length(outplantDates)),
                        "SKB-DO-var" = rep(0, length(outplantDates)),
                        "PGE-DO-var" = rep(0, length(outplantDates)),
                        "PGB-DO-var" = rep(0, length(outplantDates)),
                        "CIE-DO-var" = rep(0, length(outplantDates)),
                        "CIB-DO-var" = rep(0, length(outplantDates)),
                        "FBE-DO-var" = rep(0, length(outplantDates)),
                        "FBB-DO-var" = rep(0, length(outplantDates))) #Create an empty dataframe
head(DOVariance)
```

```{r}
for (j in 4:13) { #For each column with DO data
  for(i in 1:nDates) { #For each date
    DOVariance[i, j-2] <- var(DOTideData[DOTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column.
head(DOVariance) #Confirm dataframe filling.
```

## Salinity

```{r}
head(salinityTideData)
```

### Mean

```{r}
salinityMean <- data.frame("Date" = outplantDates,
                           "CIB-sal-mean" = rep(0, length(outplantDates)),
                           "CIE-sal-mean" = rep(0, length(outplantDates)),
                           "FBB-sal-mean" = rep(0, length(outplantDates)),
                           "FBE-sal-mean" = rep(0, length(outplantDates)),
                           "PGE-sal-mean" = rep(0, length(outplantDates)),
                           "SKB-sal-mean" = rep(0, length(outplantDates)),
                           "SKE-sal-mean" = rep(0, length(outplantDates)),
                           "WBB-sal-mean" = rep(0, length(outplantDates))) #Create an empty dataframe
head(salinityMean)
```

```{r}
for (j in 4:11) { #For each column with salinity data
  for(i in 1:nDates) { #For each date
    salinityMean[i, j-2] <- mean(salinityTideData[salinityTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "NaN" in the dataframe.
is.na(salinityMean) <- sapply(salinityMean, is.nan) #Replace all "NaN" with N/A
head(salinityMean) #Confirm dataframe filling. All "NaN" values are now replaced
```

### Variance

```{r}
salinityVariance <- data.frame("Date" = outplantDates,
                              "CIB-sal-var" = rep(0, length(outplantDates)),
                              "CIE-sal-var" = rep(0, length(outplantDates)),
                              "FBB-sal-var" = rep(0, length(outplantDates)),
                              "FBE-sal-var" = rep(0, length(outplantDates)),
                              "PGE-sal-var" = rep(0, length(outplantDates)),
                              "SKB-sal-var" = rep(0, length(outplantDates)),
                              "SKE-sal-var" = rep(0, length(outplantDates)),
                              "WBB-sal-var" = rep(0, length(outplantDates))) #Create an empty dataframe
head(salinityVariance)
```

```{r}
for (j in 4:11) { #For each column with salinity data
  for(i in 1:nDates) { #For each date
    salinityVariance[i, j-2] <- var(salinityTideData[salinityTideData$Date == outplantDates[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as N/A in the dataframe.
head(salinityVariance) #Confirm dataframe filling.
```

## Temperature

```{r}
head(temperatureData)
```

```{r}
outplantDateCharacters <- as.character(outplantDates) #Convert outplant dates to characters
temperatureData$DateCharacters <- as.character(temperatureData$Date) #Convert dates to characters
```

### Mean

```{r}
temperatureMean <- data.frame("Date" = outplantDateCharacters,
                              "WBE-temp-mean" = rep(0, length(outplantDates)),
                              "WBB-temp-mean" = rep(0, length(outplantDates)),
                              "SKE-temp-mean" = rep(0, length(outplantDates)),
                              "SKB-temp-mean" = rep(0, length(outplantDates)),
                              "PGE-temp-mean" = rep(0, length(outplantDates)),
                              "PGB-temp-mean" = rep(0, length(outplantDates)),
                              "CIE-temp-mean" = rep(0, length(outplantDates)),
                              "CIB-temp-mean" = rep(0, length(outplantDates)),
                              "FBE-temp-mean" = rep(0, length(outplantDates)),
                              "FBB-temp-mean" = rep(0, length(outplantDates))) #Create an empty dataframe, but be sure to use outplantDateCharacters
head(temperatureMean)
```

```{r}
for (j in 3:12) { #For each column with temperature data
  for(i in 1:nDates) { #For each date
    temperatureMean[i, j-1] <- mean(temperatureData[temperatureData$DateCharacters == outplantDateCharacters[i], j], na.rm = TRUE) #Find and save the mean value of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "Inf" in the dataframe.
is.na(temperatureMean) <- sapply(temperatureMean, is.nan) #Replace all "NaN" with N/A
head(temperatureMean) #Confirm dataframe filling. All "NaN" values are now replaced
```

```{r}
temperatureMean$Date <- outplantDates #Replace temperatureMean$Date with outplantDates so they are dates 
head(temperatureMean)
```

### Variance

```{r}
temperatureVariance <- data.frame("Date" = outplantDateCharacters,
                                 "WBE-temp-var" = rep(0, length(outplantDates)),
                                 "WBB-temp-var" = rep(0, length(outplantDates)),
                                 "SKE-temp-var" = rep(0, length(outplantDates)),
                                 "SKB-temp-var" = rep(0, length(outplantDates)),
                                 "PGE-temp-var" = rep(0, length(outplantDates)),
                                 "PGB-temp-var" = rep(0, length(outplantDates)),
                                 "CIE-temp-var" = rep(0, length(outplantDates)),
                                 "CIB-temp-var" = rep(0, length(outplantDates)),
                                 "FBE-temp-var" = rep(0, length(outplantDates)),
                                 "FBB-temp-var" = rep(0, length(outplantDates))) #Create an empty dataframe, but be sure to use outplantDateCharacters
head(temperatureVariance)
```

```{r}
for (j in 3:12) { #For each column with temperature data
  for(i in 1:nDates) { #For each date
    temperatureVariance[i, j-1] <- var(temperatureData[temperatureData$DateCharacters == outplantDateCharacters[i], j], na.rm = TRUE) #Find and save the variance of the designated column at each date.
  }
} #The loop will cycle through each date first in one column, then move to the next column. Any days with no non-missing data will save as "Inf" in the dataframe.
head(temperatureVariance) #Confirm dataframe filling. All "Inf" values are now replaced
```

```{r}
temperatureVariance$Date <- outplantDates #Replace temperatureVariance$Date with outplantDates so they are dates 
head(temperatureVariance)
```

## Merge all dataframes together

```{r}
dailyEnvironmentalData <- cbind(pHMean, pHVariance,
                                DOMean, DOVariance,
                                salinityMean, salinityVariance, 
                                temperatureMean, temperatureVariance) #Use cbind to merge all of the dataframes together
colnames(dailyEnvironmentalData) #View column names
```

```{r}
dailyEnvironmentalData <- dailyEnvironmentalData[-c(11, 21, 32, 43, 52, 61, 72)] #Remove all redundant "Date" columns
colnames(dailyEnvironmentalData) #Confirm column removal
```

# Environmental data NMDS

```{r}
dailyEnvironmentalDataCorrected <- dailyEnvironmentalData #Duplicate dataframe
rownames(dailyEnvironmentalDataCorrected) <- dailyEnvironmentalDataCorrected$Date #Save dates as rownames
dailyEnvironmentalDataCorrected <- dailyEnvironmentalDataCorrected[, -1] #Remove date column
head(dailyEnvironmentalDataCorrected) #Confirm changes
```

```{r}
envData.log <- log(dailyEnvironmentalDataCorrected + 1) #Log transform data before analysis
#envData.log[is.na(envData.log)] <- 0 #Replace NAs with 0s
head(envData.log) #View transformation
```

```{r}
envData.log <- envData.log[-c(32:34),] #Remove last three rows since the outplant ended before then
tail(envData.log)
```


```{r}
nmds.scree(envData.log, distance = "gower", k = 10, autotransform = FALSE, trymax = 20) #Create a screeplot to compare the stress for solutions across different k values from 2 to 10. Use 20 different random start configurations. As the number of ordination axes increases, stress is minimized because the NMDS algorithm is trying to represent p dimensional data in k dimensions.
```

```{r}
envData.log.gower.NMDS <- metaMDS(envData.log, distance = 'gower', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix on log transformed data using Gower's.
envData.log.gower.NMDS$stress
```

```{r}
nmds.monte(envData.log, distance = "gower", k = 2, autotransform = FALSE, trymax = 20) #Perform a randomization test to determine if the solution for k dimensions is significant. The observed stress value, 0.07650153, is less than the expected stress value. P-value = 0.00990099
```

```{r}
stressplot(envData.log.gower.NMDS) #Make Shepard plot to visualize the relationship between original dissimilarities (distance matrix) and distnaces in ordination space. The non-metric R-squared value is 0.994 (redundant with observed stress value and p-value from the randomization test)
```

```{r}
vec.envData.log.gower <- envfit(envData.log.gower.NMDS$points, envData.log, perm = 1000) #Calculate loadings by correlating NMDS scores with original variables
vec.envData.log.gower #Look at loadings
```

```{r}
ordiplot(envData.log.gower.NMDS, choices = c(1,2), type = "text", display = "sites", xlab = "Axis 1", ylab = "Axis 2") #Plot basic NMDS
plot(vec.envData.log.gower, p.max = 0.001, col = 'blue') #Plot loadings that are significant at the 0.001 level
```






