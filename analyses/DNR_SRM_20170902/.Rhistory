head(SRMDataNMDSNonNormalizedPivoted) #Confirm column merge
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column removal
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNonNormalizedPivotedCorrected <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrected[is.na(SRMDataNMDSNonNormalizedPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrected) #Confirm there are no NAs
area.protID <- SRMDataNMDSNonNormalizedPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID) <- SRMDataNMDSNonNormalizedPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID) #Confirm changes
head(area.protID) #Confirm changes
area.t <- t(area.protID) #Transpose the file so that rows and columns are switched
head(area.t) #Confirm transposition
area.tra <- (area.t+1) #Add 1 to all values before transforming
area.tra <- data.trans(area.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.euclidean <- metaMDS(area.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE)
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
c
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID2) #Confirm changes
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
head(area2.t) #Confirm transposition
colnames(BarplotsTechnicalReplicateAverages) <- colnames(area2.t)
BarplotsTechnicalReplicateAverages <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store averaged values
colnames(BarplotsTechnicalReplicateAverages) <- colnames(area2.t)
BarplotsTechnicalReplicateAverages
BarplotsTechnicalReplicateSE <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store standard error values
length(area2.t)-1
for(i in 1:(length(area2.t)-1)) {
BarplotsTechnicalReplicateAverages[i,] <- mean(BarplotsTechnicalReplicateAverages[i,], BarplotsTechnicalReplicateAverages[i+1,]) #Find the mean
BarplotsTechnicalReplicateSE[i,] <- sqrt(var(BarplotsTechnicalReplicateAverages[i,], BarplotsTechnicalReplicateAverages[i+1,])) #Find the SE
}
View(BarplotsTechnicalReplicateAverages)
View(area2.t)
for(i in 1:(length(area2.t)-1)) {
BarplotsTechnicalReplicateAverages[i,] <- mean(area2.t[i,], area2.t[i+1,]) #Find the mean
BarplotsTechnicalReplicateSE[i,] <- sqrt(var(area2.t[i,], area2.t[i+1,])) #Find the SE
}
View(BarplotsTechnicalReplicateAverages)
View(BarplotsTechnicalReplicateSE)
View(area2.t)
str(area2.t)
area2.t <- data.frame(area2.t)
str(area2.t)
area2.t
BarplotsTechnicalReplicateAverages <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store averaged values
BarplotsTechnicalReplicateSE <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store standard error values
for(i in 1:(length(area2.t)-1)) {
BarplotsTechnicalReplicateAverages[i,] <- mean(area2.t[i,], area2.t[i+1,]) #Find the mean
BarplotsTechnicalReplicateSE[i,] <- sqrt(var(area2.t[i,], area2.t[i+1,])) #Find the SE
}
View(BarplotsTechnicalReplicateAverages)
View(BarplotsTechnicalReplicateSE)
mean(area2.t[i,], area2.t[i+1,])
str(area2.t)
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMDataNonNormalizedNMDS <- SRMDataNMDS #Create a duplicate dataframe
SRMDataNonNormalizedNMDS <- SRMDataNMDS[,-6] #Remove TIC column
head(SRMDataNonNormalizedNMDS) #Confirm creation
library(reshape2) #Instal package to pivot table
SRMDataNMDSNonNormalizedPivoted <- dcast(SRMDataNonNormalizedNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSNonNormalizedPivoted) #Confirm cast.
SRMDataNMDSNonNormalizedPivoted$RowNames <- paste(SRMDataNMDSNonNormalizedPivoted$Protein.Name, SRMDataNMDSNonNormalizedPivoted$Peptide.Sequence, SRMDataNMDSNonNormalizedPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column merge
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column removal
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNonNormalizedPivotedCorrected <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrected[is.na(SRMDataNMDSNonNormalizedPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrected) #Confirm there are no NAs
area.protID <- SRMDataNMDSNonNormalizedPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID) <- SRMDataNMDSNonNormalizedPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID) #Confirm changes
area.t <- t(area.protID) #Transpose the file so that rows and columns are switched
head(area.t) #Confirm transposition
area.tra <- (area.t+1) #Add 1 to all values before transforming
area.tra <- data.trans(area.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID2) #Confirm changes
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
head(area2.t) #Confirm transposition
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
d
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
NMDSCoordinates <- proc.nmds.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinates) #Confirm dataframe creation
nSamples <- length(NMDSCoordinates)/2 #Calculate the number of samples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinates) #Save rownames as a new vector
technicalReplicates #Confirm vector creation
technicalReplicateDistances <- data.frame(Sample = technicalReplicates[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistances[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
tail(technicalReplicateDistances) #Confirm dataframe creation
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
head(SRMDataNMDSPivotedCorrected) #Dataset I'll use to average technical replicates, from my first R script (NMDS for Technical Replication)
SRMDataNMDSAveraged <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store averaged values
row.names(SRMDataNMDSAveraged) <- SRMDataNMDSPivotedCorrected$RowNames #Add row names
head(SRMDataNMDSAveraged) #Confirm changes
for(i in 1:(length(SRMDataNMDSPivotedCorrected))) { #Average normalized area values for consecutive columns
SRMDataNMDSAveraged[,i] <- (SRMDataNMDSPivotedCorrected[,i]+SRMDataNMDSPivotedCorrected[,i+1])/2
}
head(SRMDataNMDSAveraged) #Confirm averaging
SRMDataNMDSAveraged <- SRMDataNMDSAveraged[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Remove even-numbered columns, since those consecutive columns are not technical replicates
head(SRMDataNMDSAveraged) #Confirm column removal
colnames(SRMDataNMDSAveraged) <- technicalReplicates[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Add column names
colnames(SRMDataNMDSAveraged) #Confirm column naming
head(SRMDataNMDSAveraged) #Confirm column naming
SRMDataNMDSAveragedCorrected <- SRMDataNMDSAveraged #Duplicate dataframe
SRMDataNMDSAveragedCorrected[is.na(SRMDataNMDSAveragedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSAveragedCorrected) #Confirm there are no NAs
area.protID4 <- SRMDataNMDSAveragedCorrected #Save all area data as a new dataframe
head(area.protID4) #Confirm changes
area4.t <- t(area.protID4) #Transpose the file so that rows and columns are switched
head(area4.t) #Confirm transposition
area4.tra <- (area4.t+1) #Add 1 to all values before transforming
area4.tra <- data.trans(area4.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.averaged.euclidean <- metaMDS(area4.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
ordiplot(proc.nmds.averaged.euclidean, choices = c(1,2), type = "points", display = "sites") #Plot basic NMDS
temporaryData <- data.frame(Sample.Number = technicalReplicates,
y = rep(x = 0, times = length(technicalReplicates))) #Create a temporary dataframe with technical replicate names used in NMDS
head(temporaryData) #Confirm dataframe creation
NMDSColorShapeCustomization <- merge(x = temporaryData, y = biologicalReplicates, by = "Sample.Number") #Merge biological information with samples used
head(NMDSColorShapeCustomization) #Confirm merge
tail(NMDSColorShapeCustomization) #Confirm merge
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[,-2] #Remove empty column
head(NMDSColorShapeCustomization) #Confirm removal
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[seq(from = 1, to = 91, by = 2),] #Keep only every other row
head(NMDSColorShapeCustomization) #Confirm changes
NMDSColorShapeCustomization$Sample.Number #Confirm changes
attach(NMDSColorShapeCustomization)
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[order(Site),] #Reorder so sites are sorted alphabetically
head(NMDSColorShapeCustomization) #Confirm sorting
detach(NMDSColorShapeCustomization)
NMDS.Colors <- c(rep(x = "red", times = sum(NMDSColorShapeCustomization$Site == "CI")),
rep(x = "blue", times = sum(NMDSColorShapeCustomization$Site == "FB")),
rep(x = "black", times = sum(NMDSColorShapeCustomization$Site == "PG")),
rep(x = "green", times = sum(NMDSColorShapeCustomization$Site == "SK")),
rep(x = "magenta", times = sum(NMDSColorShapeCustomization$Site == "WB"))) #Create a color vector
NMDSColorShapeCustomization[,4] <- NMDS.Colors #Add the color vector to the dataframe
head(NMDSColorShapeCustomization) #Confirm addition
attach(NMDSColorShapeCustomization)
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[order(Eelgrass.Condition),] #Reorder so eelgrass condition is sorted alphabetically
head(NMDSColorShapeCustomization) #Confirm sorting
detach(NMDSColorShapeCustomization)
NMDS.Shapes <- c(rep(x = 16, times = sum(NMDSColorShapeCustomization$Eelgrass.Condition == "Bare")),
rep(x = 17, times = sum(NMDSColorShapeCustomization$Eelgrass.Condition == "Eelgrass"))) #Make a shape vector
NMDSColorShapeCustomization[,5] <- NMDS.Shapes #Add the shape vector to the dataframe
head(NMDSColorShapeCustomization) #Confirm addition
attach(NMDSColorShapeCustomization)
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[order(Sample.Number),] #Resort by sample number
head(NMDSColorShapeCustomization) #Confirm sorting
detach(NMDSColorShapeCustomization)
colnames(NMDSColorShapeCustomization) <- c("Sample.Number", "Site", "Eelgrass.Condition", "Color", "Shape") #Change column names
head(NMDSColorShapeCustomization) #Confirm change
fig.nmds <- ordiplot(proc.nmds.averaged.euclidean, choices=c(1,2), type='none', display='sites', xlab='Axis 1', ylab='Axis 2', cex=0.5) #Save NMDS as a new object
points(fig.nmds, "sites", col = NMDSColorShapeCustomization$Color, pch = NMDSColorShapeCustomization$Shape)
dissimArea4.t <- vegdist(area4.t, "euclidean") #Calculate dissimilarity matrix
ANOSIMReplicates <- biologicalReplicates[c(1:49),] #Subset sample numbers used as IDs in ANOSIM
row.names(ANOSIMReplicates) <- ANOSIMReplicates[,1] #Assign sample numbers as row names
ANOSIMReplicates <- ANOSIMReplicates[,-1] #Remove Sample.Number column
head(ANOSIMReplicates) #Confirm changes
str(ANOSIMReplicates) #Examine structure
ANOSIMReplicates$Site <- factor(ANOSIMReplicates$Site) #Make sure only preesnt factors are recognized
ANOSIMReplicates$Eelgrass.Condition <- factor(ANOSIMReplicates$Eelgrass.Condition) #Make sure only preesnt factors are recognized
str(ANOSIMReplicates) #Confirm structure
siteANOSIM <- anosim(dat = dissimArea4.t, grouping = ANOSIMReplicates[,1]) #One-way ANOSIM by Site
summary(siteANOSIM)
plot(siteANOSIM)
for(i in 1:(length(area2.t)-1)) {
BarplotsTechnicalReplicateAverages[i,] <- average(area2.t[i,], area2.t[i+1,]) #Find the mean
BarplotsTechnicalReplicateSE[i,] <- sqrt(var(area2.t[i,], area2.t[i+1,])) #Find the SE
}
for(i in 1:(length(area2.t)-1)) {
BarplotsTechnicalReplicateAverages[i,] <- mean(area2.t[i,], area2.t[i+1,]) #Find the mean
BarplotsTechnicalReplicateSE[i,] <- sqrt(var(area2.t[i,], area2.t[i+1,])) #Find the SE
}
BarplotsTechnicalReplicateAverages
dissimArea4.t <- vegdist(area4.t, "euclidean") #Calculate dissimilarity matrix
ANOSIMReplicates <- biologicalReplicates[c(1:49),] #Subset sample numbers used as IDs in ANOSIM
row.names(ANOSIMReplicates) <- ANOSIMReplicates[,1] #Assign sample numbers as row names
ANOSIMReplicates <- ANOSIMReplicates[,-1] #Remove Sample.Number column
head(ANOSIMReplicates) #Confirm changes
str(ANOSIMReplicates) #Examine structure
ANOSIMReplicates$Site <- factor(ANOSIMReplicates$Site) #Make sure only preesnt factors are recognized
ANOSIMReplicates$Eelgrass.Condition <- factor(ANOSIMReplicates$Eelgrass.Condition) #Make sure only preesnt factors are recognized
str(ANOSIMReplicates) #Confirm structure
siteANOSIM <- anosim(dat = dissimArea4.t, grouping = ANOSIMReplicates[,1]) #One-way ANOSIM by Site
summary(siteANOSIM)
area2.protID #From 2017-09-06-NMDS-for-Technical-Replication
area2.protID <- data.frame(area2.protID)
area2.protID #From 2017-09-06-NMDS-for-Technical-Replication
area.protID2 #From 2017-09-06-NMDS-for-Technical-Replication
area.protID2 <- data.frame(area2.protID) #Save as a data.frame
area.protID2 <- data.frame(area.protID2) #Save as a data.frame
str(area2.t)
area.protID2 <- data.frame(area.protID2) #Save as a data.frame
str(area.protID2)
mean(area.protID2[,i], area.protID2[,i+1])
ave(area.protID2[,i], area.protID2[,i+1])
str(area2.t)
area2.t <- data.frame(area2.t)
ave(area2.t[i,], area2.t[i+1,])
sqrt(var(area.protID2[,i], area.protID2[,i+1]))
ave(area.protID2[,i], area.protID2[,i+1])
var(area.protID2[,i], area.protID2[,i+1])
sqrt(var(area.protID2[1,i], area.protID2[1,i+1]))
sd(area.protID2[,i], area.protID2[,i+1])
?sd
?se
SRMData #From 2017-09-06-NMDS-for-Technical-Replication
SRMDataNMDSAveragedCorrected #From 2017-09-06-NMDS-for-Technical-Replication
boxplot(SRMDataNMDSAveragedCorrected)
boxplot(SRMDataNMDSAveragedCorrected[1,])
boxplot(SRMDataNMDSAveragedCorrected[1,])
boxplot(SRMDataNMDSAveragedCorrected)
?boxplot
boxplot(SRMDataNMDSAveragedCorrected$`O01-1`)
boxplot(t(SRMDataNMDSAveragedCorrected))
boxplotData <- t(SRMDataNMDSAveragedCorrected)
boxplotData
boxplotData <- data.frame(t(SRMDataNMDSAveragedCorrected))
boxplotData
boxplot(boxplotData$CHOYP_ACAA2.1.1.m.30666.ELGLNNDITNMNGGAIALGHPLAASGTR.y10)
boxplotData <- data.frame(t(SRMDataNMDSAveragedCorrected))
boxplot(boxplotData)
biologicalReplicates
rownames(biologicalReplicates) <- biologicalReplicates$Site
rownames(biologicalReplicates) <- biologicalReplicates$Sample.Number
merge(x = boxplotData, y = biologicalReplicates, by = rownames(boxplotData))
boxplotData$Sample.Number <- rownames(boxplotData) #Save rownames as a new column
merge(x = boxplotData, y = biologicalReplicates, by = Sample.Number)
biologicalReplicates
merge(x = boxplotData, y = biologicalReplicates, by = Sample.Number)
boxplotData
merge(x = boxplotData, y = biologicalReplicates, by = Sample.Number)
boxplotData
head(boxplotData)
head(biologicalReplicates) #Confirm chagnes
head(biologicalReplicates) #Confirm changes
Sample.Number
boxplotData <- merge(x = boxplotData, y = biologicalReplicates, by = Sample.Number)
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by = Sample.Number)
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by,y = Sample.Number)
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by.y = Sample.Number)
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by = "Sample.Number")
head(boxplotData)
rownames(boxplotData) <- boxplotData$Sample.Number #Set sample number as row names
boxplotData <- boxplotData[-1] #Remove Sample.Number column
head(boxplotData) #Confirm changes
CaseInlet <- subset(x = boxplotData, subset = boxplotData$Site == "CI")
FidalgoBay <- subset(x = boxplotData, subset = boxplotData$Site == "FB")
PortGamble <- subset(x = boxplotData, subset = boxplotData$Site == "PG")
SkokomishRiver <- subset(x = boxplotData, subset = boxplotData$Site == "SK")
WillapaBay <- subset(x = boxplotData, subset = boxplotData$Site == "WB")
CaseInlet
boxplotData
View(boxplotData)
View(CaseInlet)
boxplot(boxplotData$CHOYP_ACAA2.1.1.m.30666.ELGLNNDITNMNGGAIALGHPLAASGTR.y10 ~ boxplotData$Site)
boxplot(boxplotData$CHOYP_ACAA2.1.1.m.30666.ELGLNNDITNMNGGAIALGHPLAASGTR.y10 ~ boxplotData$Site + boxplotData$Eelgrass.Condition)
boxplot(boxplotData$CHOYP_ACAA2.1.1.m.30666.ELGLNNDITNMNGGAIALGHPLAASGTR.y10 ~ boxplotData$Site)
str(boxplotData)
boxplotData$Site <- as.factor(boxplotData$Site)
boxplotData$Eelgrass.Condition <- as.factor(boxplotData$Eelgrass.Condition)
str(boxplotData)
boxplotData$Site <- as.factor(boxplotData$Site)
str(boxplotData)
biologicalReplicates$Site
View(biologicalReplicates)
biologicalReplicates <- biologicalReplicates[,-c(50,100)] #Remove blanks
biologicalReplicates$Site
biologicalReplicates <- biologicalReplicates[-c(50,100),] #Remove blanks
biologicalReplicates$Site
biologicalReplicates$Site <- as.factor(biologicalReplicates$Site)
biologicalReplicates$Eelgrass.Condition <- as.factor(biologicalReplicates$Eelgrass.Condition) #Remove 0 as a factor
str(biologicalReplicates) #Confirm factor reset
biologicalReplicates$Site <- as.factor(biologicalReplicates$Site) #Remove 0 as a factor
str(biologicalReplicates) #Confirm factor reset
unique(biologicalReplicates$Site)
biologicalReplicates$Eelgrass.Condition <- factor(biologicalReplicates$Eelgrass.Condition) #Remove 0 as a factor
biologicalReplicates$Site <- factor(biologicalReplicates$Site) #Remove 0 as a factor
str(biologicalReplicates) #Confirm factor reset
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by = "Sample.Number") #Merge together
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
rownames(biologicalReplicates) <- biologicalReplicates$Sample.Number #Set sample number as row names
head(biologicalReplicates) #Confirm changes
biologicalReplicates <- biologicalReplicates[-c(50,100),] #Remove blanks
biologicalReplicates$Site <- factor(biologicalReplicates$Site) #Remove 0 as a factor
biologicalReplicates$Eelgrass.Condition <- factor(biologicalReplicates$Eelgrass.Condition) #Remove 0 as a factor
str(biologicalReplicates) #Confirm factor reset
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by = "Sample.Number") #Merge together
boxplotData
boxplotData$Site
View(boxplotData)
boxplotData$Site <- factor(boxplotData$Site)
boxplotData$Eelgrass.Condition <- factor(boxplotData$Eelgrass.Condition)
SRMDataNMDSAveragedCorrected #From 2017-09-06-NMDS-for-Technical-Replication. Average normalized area data.
boxplotData <- data.frame(t(SRMDataNMDSAveragedCorrected)) #Transpose the data
boxplotData$Sample.Number <- rownames(boxplotData) #Save rownames as a new column
head(boxplotData) #Confirm changes
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
rownames(biologicalReplicates) <- biologicalReplicates$Sample.Number #Set sample number as row names
head(biologicalReplicates) #Confirm changes
biologicalReplicates <- biologicalReplicates[-c(50,100),] #Remove blanks
biologicalReplicates$Site <- factor(biologicalReplicates$Site) #Remove 0 as a factor
biologicalReplicates$Eelgrass.Condition <- factor(biologicalReplicates$Eelgrass.Condition) #Remove 0 as a factor
str(biologicalReplicates) #Confirm factor reset
boxplotData <- merge(x = biologicalReplicates, y = boxplotData, by = "Sample.Number") #Merge together
head(boxplotData) #Confirm merge
boxplotData$Site <- factor(boxplotData$Site)
boxplotData$Eelgrass.Condition <- factor(boxplotData$Eelgrass.Condition)
rownames(boxplotData) <- boxplotData$Sample.Number #Set sample number as row names
boxplotData <- boxplotData[-1] #Remove Sample.Number column
head(boxplotData) #Confirm changes
boxplot(boxplotData$CHOYP_ACAA2.1.1.m.30666.ELGLNNDITNMNGGAIALGHPLAASGTR.y10 ~ boxplotData$Site)
nTransitions <- length(boxplotData)
View(boxplotData)
nTransitions <- (length(boxplotData) - 2) #The number of columns with unique transition IDs
boxplot(boxplotData[,3] ~ boxplotData$Site) #Make b
0:nTransitions
nTransitions <- (length(boxplotData)) #The number of columns in the dataframe. The first 2 columns are Site and Eelgrass.Condition
3:nTransitions
colname(boxplotData[,1])
col.name(boxplotData[,1])
colnames(boxplotData[,1])
colnames(boxplotData[,3])
colnames(boxplotData)
boxplotFilenames <- colnames(boxplotData)
boxplotFilenames[1]
boxplot(boxplotData[,3] ~ boxplotData$Site, main = boxplotFilenames[3], xlab = "Sites", ylab = "Abundance")
fileName <- boxplotFilenames[i] #Set the file name
jpeg(filename = fileName, width = 1000, height = 1000) #Save using set file name
boxplot(boxplotData[,i] ~ boxplotData$Site, main = boxplotFilenames[i], xlab = "Sites", ylab = "Abundance")
dev.off()
boxplot(boxplotData[,i] ~ boxplotData$Site, main = boxplotFilenames[i], xlab = "Sites", ylab = "Abundance")
boxplot(boxplotData[,3] ~ boxplotData$Site, main = boxplotFilenames[3], xlab = "Sites", ylab = "Abundance")
fileName <- boxplotFilenames[3] #Set the file name
jpeg(filename = fileName, width = 1000, height = 1000) #Save using set file name
boxplot(boxplotData[,3] ~ boxplotData$Site, main = boxplotFilenames[3], xlab = "Sites", ylab = "Abundance")
dev.off()
for(i in 3:nTransitions) { #For all of my columns with transition IDs
fileName <- boxplotFilenames[i] #Set the file name
jpeg(filename = fileName, width = 1000, height = 1000) #Save using set file name
boxplot(boxplotData[,i] ~ boxplotData$Site, xlab = "Sites", ylab = "Abundance") #Create the boxplot
dev.off() #Close file
}
boxplotFilenames$mod <- rep("Eelgrass", 113)
boxplotFilenames[,2] <- rep("Eelgrass", 113)
boxplotFilenames <- data.frame(boxplotFilenames = boxplotFilenames,
modifier = rep("Eelgrass", 113))
View(boxplotFilenames)
boxplotFilenames <- data.frame(filenames = colnames(boxplotData),
modifier = rep("Eelgrass", 113))
boxplotFilenames$Eelgrass <- paste(boxplotFilenames$filenames, boxplotFilenames$modifier)
View(boxplotFilenames)
boxplot(boxplotData[,5] ~ boxplotData$Site + boxplotData$Eelgrass.Condition, xlab = "Sites", ylab = "Abundance") #Create the boxplot
boxplot(boxplotData[,5] ~ boxplotData$Site + boxplotData$Eelgrass.Condition, main = boxplotFilenames[3,5], xlab = "Sites", ylab = "Abundance") #Create the boxplot
boxplot(boxplotData[,5] ~ boxplotData$Site + boxplotData$Eelgrass.Condition, main = boxplotFilenames$Eelgrass[5], xlab = "Sites", ylab = "Abundance") #Create the boxplot
?boxplot
boxplot(boxplotData[,5] ~ boxplotData$Site + boxplotData$Eelgrass.Condition, main = boxplotFilenames$Eelgrass[5], xlab = "Sites", ylab = "Abundance", names = c("CI.Bare", "FB.Bare","PG.Bare", "SK.Bare", "WB.Bare", "CI.Eelgrass", "FB.Eelgrass", "PG.Eelgrass", "SK.Eelgrass", "WB.Eelgrass"))
for(i in 3:nTransitions) { #For all of my columns with transition IDs
fileName <- boxplotFilenames$Eelgrass[i] #Set the file name choices as the third column
jpeg(filename = fileName, width = 1000, height = 1000) #Save using set file name
boxplot(boxplotData[,i] ~ boxplotData$Site + boxplotData$Eelgrass.Condition, xlab = "Sites", ylab = "Abundance", names = c("CI.Bare", "FB.Bare", "PG.Bare", "SK.Bare", "WB.Bare", "CI.Eelgrass", "FB.Eelgrass", "PG.Eelgrass", "SK.Eelgrass", "WB.Eelgrass")) #Create the boxplot
dev.off() #Close file
}
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMDataNonNormalizedNMDS <- SRMDataNMDS #Create a duplicate dataframe
SRMDataNonNormalizedNMDS <- SRMDataNMDS[,-6] #Remove TIC column
head(SRMDataNonNormalizedNMDS) #Confirm creation
library(reshape2) #Instal package to pivot table
SRMDataNMDSNonNormalizedPivoted <- dcast(SRMDataNonNormalizedNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSNonNormalizedPivoted) #Confirm cast.
SRMDataNMDSNonNormalizedPivoted$RowNames <- paste(SRMDataNMDSNonNormalizedPivoted$Protein.Name, SRMDataNMDSNonNormalizedPivoted$Peptide.Sequence, SRMDataNMDSNonNormalizedPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column merge
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-c(1:3)] #Remove unmerged columns
