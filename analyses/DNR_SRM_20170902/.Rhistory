if(!is.null(outfile)){ #write table to outfile
write.table(z,file=paste(outfile,'.csv',sep=''),row.names=FALSE,quote=FALSE,sep=',')
} #end save outfile
}
else stop('No outliers exist')
} #end sd outliers w/o groups
#sd outliers w/ groups
else{
if(!is.null(outfile)) write('',file=outfile) #empty outfile if it exists
n<-by.names(x,by) #create by variable
y<-cbind(n,x)
m<-levels(n[,2]) #create object with group levels
z<-vector('list',length(m))	#create list object for output
names(z)<-m #assign names to list components
for(i in 1:length(m)){ #loop thru by groups
t0<-y[n[,2]==m[i],,drop=FALSE] #select records within group
y1<-as.data.frame(subset(t0,select=eval(parse(text=id)))) #select plot.id variables
y2<-as.data.frame(subset(t0,select=eval(parse(text=var)))) #select variables to standardize
t1<-scale(y2) #calculate sd's
t2<-abs(t1)>=sd.limit
row.vector<-apply(t2,1,FUN='any',na.rm=TRUE)#select rows with extremes
col.vector<-apply(t2,2,FUN='any',na.rm=TRUE)#select cols with extremes
if(sum(row.vector)>0){
t3<-t1[row.vector,col.vector,drop=FALSE]
t3[abs(t3)<sd.limit]<-NA
t3<-round(t3,digits)
t4<-as.data.frame(y1[row.vector,,drop=FALSE])
z[[i]]<-cbind(t4,t3)
if(!is.null(outfile)){ #write table to outfile
write(m[i],file=paste(outfile,'.csv',sep=''),append=TRUE)
write.table(z,file=paste(outfile,'.csv',sep=''),quote=FALSE,append=TRUE,sep=',')
} #end save outfile
}
else z[[i]]<-NULL
} #end loop thru groups
} #end sd outliers w/groups
return(z)
} #end function
`uv.plots` <-
function(x,var=NULL,col.fill='blue',col.point='black',
col.line='red',...){
oldpar<-par(no.readonly=TRUE)
if(!is.null(var)){
y<-subset(x,select=eval(parse(text=var))) #select variables to summarize
y<-as.data.frame(y)
}
else{y<-as.data.frame(x)} #graphics settings
#layout plot
layout(matrix(c(1,1,2,3,4,5),
nrow=3,ncol=2,byrow=TRUE),
heights=c(.1,.45,.45),widths=c(.5,.5))
par(mar=c(1,1,1,1))
#loop thru variables
for(i in 1:ncol(y)){
#plot title
plot.new()
text(.5,.5,labels=names(y[i]),
font=2,cex=3,xpd=TRUE)
#histogram (upper left panel)
par(mar=c(5,5,4,2))
hist(y[[i]],prob=TRUE,col=col.fill,
xaxs='i',yaxs='i',xlab=names(y[i]),
main='Histogram',...)
lines(density(y[[i]]))
#box-and-whisker plot (upper right panel)
par(mar=c(5,5,4,2))
boxplot(y[i],col=col.fill,ylab=names(y[i]),
main='Box-and-Whisker Plot',...)
#empirical cumulative distribution function plot (lower left panel)
par(mar=c(5,5,4,2))
plot(sort(y[[i]]),type='o',col=col.point,yaxs='i',xaxs='i',
xlab='Cumulative Number of Plots',ylab=names(y[i]),
main='ECDF Plot',...)
#normal quantile-quantile plot (lower right panel)
par(mar=c(5,5,4,2))
qqnorm(y[,i],datax=TRUE,col=col.point,
main='Normal Q-Q Plot',...)
y.IQR<-IQR(y[,i],na.rm=TRUE)
if(y.IQR>0)	qqline(y[,i],datax=TRUE,col=col.line,...)
par(mar=c(1,1,1,1))
if(!i==ncol(y)) {readline("Press return for next plot ")}
} #end loop thru variables
par(oldpar)
} #end function
install.packages("vegan") #Install vegan package
install.packages("vegan")
library(vegan)
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93]
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93]
area2.t <- t(area.protID2)
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE)
stressplot(proc.nmds)
ordiplot(proc.nmds)
View(area.protID2)
View(area2.t)
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE)
stressplot(proc.nmds)
ordiplot(proc.nmds)
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE)
stressplot(proc.nmds)
ordiplot(proc.nmds)
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE)
stressplot(proc.nmds.euclidean)
ordiplot(proc.nmds.euclidean)
proc.nmds.euclidean.log <-  metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE)
stressplot(proc.nmds.euclidean.log)
ordiplot(proc.nmds.euclidean)
?stressplot
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
stressplot(proc.nmds.euclidean)
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 3, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds) #Plot basic NMDS
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds) #Plot basic NMDS
proc.nmds.log <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance and log transformation
proc.nmds.log <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance and log transformation
stressplot(proc.nmds.log) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds) #Plot basic NMDS
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean) #Plot basic NMDS
View(SRMDataNMDSPivotedCorrected)
View(SRMDataNMDSPivoted)
write.csv(SRMDataNMDSPivoted, file = "2017-09-07-SRM-Data-NMDS-Pivoted.csv") #Wrote out as .csv to make future analyses easier.
ordiplot(proc.nmds) #Plot basic NMDS
ordiplot(proc.nmds) #Plot basic NMDS
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds) #Plot basic NMDS
stressplot(proc.nmds.log) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
?ordiplot
ordiplot(proc.nmds.euclidean, type = text)
ordiplot(proc.nmds.euclidean, type = "text")
ordiplot(proc.nmds.log) #Plot basic NMDS
ordiplot(proc.nmds, type = "text", display = species)
ordiplot(proc.nmds, type = "text", display = "species")
ordiplot(proc.nmds, type = "text", display = "sites")
ordiplot(proc.nmds.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = "euclidean", k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance and log transformation
stressplot(proc.nmds.euclidean.log)
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.autotransform <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using bray distance and autotransformation
ordiplot(proc.nmds.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 9, 10)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds) #Plot basic NMDS
ordiplot(proc.nmds, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.autotransform <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using bray distance and autotransformation
stressplot(proc.nmds.autotransform) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds.autotransform) #Plot basic NMDS
ordiplot(proc.nmds.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.log <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance and log transformation
stressplot(proc.nmds.log) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds.log) #Plot basic NMDS
ordiplot(proc.nmds.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.log
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
a
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites", xlim = c(-4e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 3e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-4e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08), ylim = c(-1e+08, 1e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08), ylim = c(-1e+08, 1e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08), ylim = c(-1e+08, 1e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08), ylim = c(-0.5e+08, 0.5e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", xlim = c(-3e+08, 4e+08)) #Plot refined NMDS displaying only samples with their names
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance
stressplot(proc.nmds) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds) #Plot basic NMDS
ordiplot(proc.nmds, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.autotransform <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using bray distance and autotransformation
stressplot(proc.nmds.autotransform) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds.autotransform) #Plot basic NMDS
ordiplot(proc.nmds.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.log <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance and log transformation
stressplot(proc.nmds.log) #Make Shepard Plot (plot of ordination distances against fit of original dissimilarities)
ordiplot(proc.nmds.log) #Plot basic NMDS
ordiplot(proc.nmds.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean) #Plot basic NMDS
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean.log) #Make Shepard plot
ordiplot(proc.nmds.euclidean.log) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
stressplot(proc.nmds.euclidean.autotransform) #Make Shepard plot
ordiplot(proc.nmds.euclidean.autotransform) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-09-08-NMDS-TechnicalReplication-NotNormalized.jpeg")
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
dev.off()
dev.off()
?jpeg
jpeg(filename = "2017-09-08-NMDS-TechnicalReplication-NotNormalized.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3)] #Keep only the Replicate.Name and Comment columns
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3)] #Keep only the Replicate.Name and Comment columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number")
head(sequenceFile) #Confirm change
sequenceFile <- sequenceFile[,c(2,3,4)] #Keep the Replicate.Name, Comment and TIC columns
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list. OBLNK2-1 and OBLNK2-2 not included.
head(masterSRMDataBiologicalReplicates)
masterSRMDataBiologicalReplicates <- masterSRMDataBiologicalReplicates[,-8] #Remove TIC Area column since it is empty
head(masterSRMDataBiologicalReplicates) #Confirm change
View(SRMDataNMDSPivotedCorrected)
View(area.protID2)
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
namea(proc.nmds.euclidean.log)
names(proc.nmds.euclidean.log)
proc.nmds.euclidean.log$species
View(area2.t)
proc.nmds.log <- metaMDS(area2.tra, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using bray distance and log transformation
ordiplot(proc.nmds.log) #Plot basic NMDS
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "species") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.log$points
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list. OBLNK2-1 and OBLNK2-2 not included.
head(masterSRMDataBiologicalReplicates)
masterSRMDataBiologicalReplicates <- masterSRMDataBiologicalReplicates[,-8] #Remove TIC Area column since it is empty
head(masterSRMDataBiologicalReplicates) #Confirm change
write.csv(x = masterSRMDataBiologicalReplicates, file = "2017-09-07-Master-SRM-Data-BiologicalReplicates-NoBlanks-NoPivot.csv")
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMDataNMDS$Normalized.Area <- SRMDataNMDS$Area/SRMDataNMDS$TIC
head(SRMDataNMDS)
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS
SRMDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
write.csv(SRMDataNMDSPivoted, file = "2017-09-07-SRM-Data-NMDS-Pivoted.csv") #Wrote out as .csv to make future analyses easier.
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID2) #Confirm changes
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
head(area2.t) #Confirm transposition
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean) #Plot basic NMDS
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean.log) #Make Shepard plot
ordiplot(proc.nmds.euclidean.log) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
stressplot(proc.nmds.euclidean.autotransform) #Make Shepard plot
ordiplot(proc.nmds.euclidean.autotransform) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
stressplot(proc.nmds.euclidean) #Make Shepard plot
stressplot(proc.nmds.euclidean.log) #Make Shepard plot
stressplot(proc.nmds.euclidean.log) #Make Shepard plot
stressplot(proc.nmds.euclidean.autotransform) #Make Shepard plot
vec.proc.nmds.euclidean <- envfit(proc.nmds.euclidean$points, area2.t, perm = 1000)
vec.proc.nmds.euclidean
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
plot(vec.sp, p.max=.01, col='blue') #Plot eigenvectors
plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
proc.nmds.euclidean$points
NMDSCoordinates <- proc.nmds.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinates)
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.2) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.25) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.1) #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.2) #Plot refined NMDS displaying only samples with their names
sqrt((NMDSCoordinates[1,1]-NMDSCoordinates[1,2])^2 + (NMDSCoordinates[2,1]-NMDSCoordinates[2,2])^2)
nSamples <- length(NMDSCoordinates)/2
length(NMDSCoordinates)/2
length(NMDSCoordinates)
View(NMDSCoordinates)
nSamples <- length(NMDSCoordinates)/4
length(NMDSCoordinates)/4
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
?ODD
??ODD
odd(3)
library(gtools)
odd(3)
odd(3) == TRUE
odd(3) == FALSE
FALSE
is.odd(3)
odd(1:10)
odd(NMDSCoordinates[1,])
oddIntegers <- seq(from = 1, to = 91, by = 2)
for(i in 1:oddIntegers) {
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i])
}
sqrt((NMDSCoordinates[1,1]-NMDSCoordinates[1,2])^2 + (NMDSCoordinates[2,1]-NMDSCoordinates[2,2])^2)
for(i in seq(from = 1, to = 91, by = 2)) {
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i])
}
sampleDistances
sampleDistances <- dataframe(length = nSamples) #Create an empty vector to store distance values
sampleDistances <- data.frame(length = nSamples) #Create an empty vector to store distance values
for(i in seq(from = 1, to = 91, by = 2)) {
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i])
}
for(i in seq(from = 1, to = 91, by = 2)) {
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i])
}
sampleDistances
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in seq(from = 1, to = 91, by = 2)) {
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i])
}
sampleDistances
sqrt((NMDSCoordinates[3,1]-NMDSCoordinates[3,2])^2 + (NMDSCoordinates[3+1,1]-NMDSCoordinates[3+1,2])^2)
sqrt((NMDSCoordinates[2,1]-NMDSCoordinates[2,2])^2 + (NMDSCoordinates[2+1,1]-NMDSCoordinates[2+1,2])^2)
for(i in seq(from = 1, to = 91, by = 2)) {print i}
for(i in seq(from = 1, to = 91, by = 2)) {print(i)}
nSamples <- length(NMDSCoordinates)/2 #Calculate the number of samples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in nSamples) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation
for(i in 1:92) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between technical replicate ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation
sqrt((NMDSCoordinates[91,1]-NMDSCoordinates[91,2])^2 + (NMDSCoordinates[91+1,1]-NMDSCoordinates[91+1,2])^2)
sampleDistances[seq(from = 1, to = 91, by = 2)]
rownames(NMDSCoordinates[seq(from = 1, to = 91, by = 2)])
rownames(NMDSCoordinates[1])
rownames(NMDSCoordinates)
technicalReplicates <- rownames(NMDSCoordinates)
technicalReplicates[1]
technicalReplicates[seq(from = 1, to = 91, by = 2)]
technicalReplicateDistances <- data.frame(x = sampleDistances[seq(from = 1, to = 91, by = 2)],
y = technicalReplicates[seq(from = 1, to = 91, by = 2)])
technicalReplicateDistances <- data.frame(x = technicalReplicates[seq(from = 1, to = 91, by = 2)],
y = sampleDistances[seq(from = 1, to = 91, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
plot(technicalReplicateDistances)
technicalReplicateDistances <- data.frame(Sample = technicalReplicates[seq(from = 1, to = 91, by = 2)],
Distance = sampleDistances[seq(from = 1, to = 91, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
?plot
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "p", cex = 0.5, pch = 19)
plot(y = technicalReplicateDistances$Sample, x = technicalReplicateDistances$Distance, type = "p", cex = 0.5, pch = 19)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "p", cex = 0.5, pch = 19)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "h", cex = 0.5, pch = 19)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "h")
?barplot
barplot(technicalReplicateDistances)
barchart(technicalReplicateDistances)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "h", cex = 0.5, pch = 19)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, cex = 0.5, pch = 19, xlab = "Sample", ylab = "Distance between Ordinations")
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, cex = 0.5, pch = 1, xlab = "Sample", ylab = "Distance between Ordinations")
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, pch = 20, xlab = "Sample", ylab = "Distance between Ordinations")
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, pch = -, xlab = "Sample", ylab = "Distance between Ordinations")
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, pch = 1, xlab = "Sample", ylab = "Distance between Ordinations")
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
