abline(transitionModel) #Plot regression
plot(x= SRMDataTransposedReplicateOne[,8], y = SRMDataTransposedReplicateTwo[,8], xlab = "Replicate 1 Area", ylab = "Replicate 2 Area", main = correlationFilenames$filename[1], type = "n") #Create plot, but do not plot points
text(x = SRMDataTransposedReplicateOne[,8], y = SRMDataTransposedReplicateTwo[,8], labels = rownames(SRMDataTransposedReplicateOne), cex = 0.7) #Plot sample ID instead of points
abline(transitionModel, col = "red") #Plot regression
legend("topleft", bty = "n", legend = paste("R2 =", format(summary(transitionModel)$adj.r.squared, digits=4))) #Plot R-squared value
summary(transitionModel)$mse
summary(transitionModel)$se
summary(transitionModel)$standard.error
summary(transitionModel)
?summary
summary(transitionModel)[1]
summary(transitionModel)[2]
summary(transitionModel)[3]
summary(transitionModel)[4]
summary(transitionModel)[5]
summary(transitionModel)$coefficients
summary(transitionModel)$coefficients[1]
summary(transitionModel)$coefficients[2]
summary(transitionModel)$coefficients[3]
summary(transitionModel)$coefficients[4]
mse <- summary(transitionModel)$coefficients[4] #Calculate mSE using residual standard error
ssx <- sum((transitionModel$SRMDataTransposedReplicateOne[,8] - mean(transitionModel$SRMDataTransposedReplicateOne[,8]))^2)
ssx <- sum((transitionModel$xlevels - mean(transitionModel$xlevels)^2))
nTransitions <- nrow(SRMDataTargetsReplicateOne) #Number of transitions used
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataTargetsOnly <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataTargetsOnly) #Confirm copy
tail(SRMDataTargetsOnly) #Confirm copy
SRMDataTargetsOnly <- SRMDataTargetsOnly[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataTargetsOnly) #Confirm column removal
SRMDataTargetsOnly <- SRMDataTargetsOnly[! SRMDataTargetsOnly$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data from target protein dataframe
head(SRMDataTargetsOnly) #Confirm removal
transform(SRMDataTargetsOnly, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataTargetsOnly$Area) #Confirm change
transform(SRMDataTargetsOnly, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataTargetsOnly$TIC) #Confirm change
SRMDataTargetsOnly <- SRMDataTargetsOnly[,-6] #Remove TIC column
head(SRMDataTargetsOnly) #Confirm creation
library(reshape2) #Instal package to pivot table
SRMDataTargetsOnlyPivoted <- dcast(SRMDataTargetsOnly, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataTargetsOnlyPivoted) #Confirm cast.
SRMDataTargetsOnlyPivoted$RowNames <- paste(SRMDataTargetsOnlyPivoted$Protein.Name, SRMDataTargetsOnlyPivoted$Peptide.Sequence, SRMDataTargetsOnlyPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataTargetsOnlyPivoted) #Confirm column merge
SRMDataTargetsOnlyPivoted <- SRMDataTargetsOnlyPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataTargetsOnlyPivoted) #Confirm column removal
SRMDataTargetsOnlyPivotedCorrected <- SRMDataTargetsOnlyPivoted #Duplicate dataframe
SRMDataTargetsOnlyPivotedCorrected[is.na(SRMDataTargetsOnlyPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataTargetsOnlyPivotedCorrected) #Confirm there are no NAs
rownames(SRMDataTargetsOnlyPivotedCorrected) <- SRMDataTargetsOnlyPivotedCorrected$RowNames #Set RowNames column as dataframe rownames
SRMDataTargetsOnlyPivotedCorrected <- subset(SRMDataTargetsOnlyPivotedCorrected, select = -c(RowNames)) #Remove RowNames column
head(SRMDataTargetsOnlyPivotedCorrected) #Confirm changes
SRMDataTargetsReplicateOne <- SRMDataTargetsOnlyPivotedCorrected[, c(seq(from = 1, to = (length(SRMDataTargetsOnlyPivotedCorrected) - 1), by = 2))] #Subset all odd columns (first replicate)
colnames(SRMDataTargetsReplicateOne) #Confirm subset
SRMDataTargetsReplicateTwo <- SRMDataTargetsOnlyPivotedCorrected[, c(seq(from = 2, to = length(SRMDataTargetsOnlyPivotedCorrected), by = 2))] #Subset all even columns (first replicate)
colnames(SRMDataTargetsReplicateTwo) #Confirm subset
SRMDataTransposedReplicateOne <- t(SRMDataTargetsReplicateOne) #Transpose Replicate 1 dataframe
head(SRMDataTransposedReplicateOne) #Confirm transposition
SRMDataTransposedReplicateTwo <- t(SRMDataTargetsReplicateTwo) #Transpose Replicate 2 dataframe
head(SRMDataTransposedReplicateTwo) #Confirm transposition
correlationFilenames <- data.frame(filenames = colnames(SRMDataTransposedReplicateOne),
modifier = rep(".jpeg", 111)) #Make a dataframe of filenames
correlationFilenames$full <- paste(correlationFilenames$filenames, correlationFilenames$modifier) #Merge the two columns together in a third column. This column has the full filename that will be used
head(correlationFilenames) #Confirm changes
nTransitions <- nrow(SRMDataTargetsReplicateOne) #Number of transitions used
for(i in 1:nTransitions) { #For all transitions
transitionModel <- lm(SRMDataTransposedReplicateTwo[,i] ~ SRMDataTransposedReplicateOne[,i]) #Predict Replicate 2 from Replicate 1
fileName <- correlationFilenames$full[i] #Set filename choice as the ith entry
jpeg(filename = fileName, width = 1000, height = 1000) #Save .jpeg using set filename
plot(x= SRMDataTransposedReplicateOne[,i], y = SRMDataTransposedReplicateTwo[,i], xlab = "Replicate 1 Area", ylab = "Replicate 2 Area", main = correlationFilenames$filename[i], type = "n") #Create plot, but do not plot points
text(x = SRMDataTransposedReplicateOne[,i], y = SRMDataTransposedReplicateTwo[,i], labels = rownames(SRMDataTransposedReplicateOne), cex = 0.7) #Plot sample ID instead of points
abline(transitionModel, col = "red") #Plot regression
legend("topleft", bty = "n", legend = paste("R2 =", format(summary(transitionModel)$adj.r.squared, digits=4))) #Plot R-squared value
dev.off() #Turn off plotting mechanism
}
?setwd #Change working directory so files are saved in the same directory as the R script
getwd
getwd()
getwd() #Change working directory so files are saved in the same directory as the R script
setwd(dir = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/")
getwd() #Confirm chagnes
nTransitions <- nrow(SRMDataTargetsReplicateOne) #Number of transitions used
for(i in 1:nTransitions) { #For all transitions
transitionModel <- lm(SRMDataTransposedReplicateTwo[,i] ~ SRMDataTransposedReplicateOne[,i]) #Predict Replicate 2 from Replicate 1
fileName <- correlationFilenames$full[i] #Set filename choice as the ith entry
jpeg(filename = fileName, width = 1000, height = 1000) #Save .jpeg using set filename
plot(x= SRMDataTransposedReplicateOne[,i], y = SRMDataTransposedReplicateTwo[,i], xlab = "Replicate 1 Area", ylab = "Replicate 2 Area", main = correlationFilenames$filename[i], type = "n") #Create plot, but do not plot points
text(x = SRMDataTransposedReplicateOne[,i], y = SRMDataTransposedReplicateTwo[,i], labels = rownames(SRMDataTransposedReplicateOne), cex = 0.7) #Plot sample ID instead of points
abline(transitionModel, col = "red") #Plot regression
legend("topleft", bty = "n", legend = paste("R2 =", format(summary(transitionModel)$adj.r.squared, digits=4))) #Plot R-squared value
dev.off() #Turn off plotting mechanism
}
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-07-SRM-Data-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
head(SRMDataNMDSNonNormalizedPivoted) #Confirm import
View(SRMDataNMDSNonNormalizedPivoted)
View(SRMDataNMDSNonNormalizedPivoted)
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-1] #Remove extraneous column
rownames(SRMDataNMDSNonNormalizedPivoted) <- SRMDataNMDSNonNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNonNormalizedPivoted)
SRMDataNMDSNonNormalizedPivotedCutoff1 <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff1 <- SRMDataNMDSNonNormalizedPivotedCutoff1[-c(1, 2, 3, 18, 21, 22, 28, 43, 55, 76, 85, 86, 87, 88, 89, 90, 91, 92, 93, 103, 106, 109, 111),] #Remove rows that don't make the cutoff
head(SRMDataNMDSNonNormalizedPivotedCutoff1) #Confirm changes
View(SRMDataNMDSNonNormalizedPivotedCutoff1) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
rownames(SRMDataNMDSNonNormalizedPivotedCutoff1) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNonNormalizedPivotedCutoff1 <- SRMDataNMDSNonNormalizedPivotedCutoff1[-88,]
rownames(SRMDataNMDSNonNormalizedPivotedCutoff1) #Confirm changes
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1 <- SRMDataNMDSNonNormalizedPivotedCutoff1 #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1[is.na(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1) #Confirm there are no NAs
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1
View(SRMDataNMDSNonNormalizedPivotedCutoff1)
View(SRMDataNMDSNonNormalizedPivotedCutoff1)
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1)
area.t <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1) #Transpose the file so that rows and columns are switched
head(area.t)
area.tra <- (area.t+1) #Add 1 to all values before transforming
area.tra <- data.trans(area.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
stressplot(proc.nmds.nonnorm.cutoff1.euclidean) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean.log <- metaMDS(area.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.nonnorm.cutoff1.euclidean.log) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
vec.proc.nmds.nonnorm.cutoff1.euclidean <- envfit(proc.nmds.nonnorm.cutoff1.euclidean$points, area.t, perm = 1000) #Calculate loadings
plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
plot(vec.proc.nmds.nonnorm.cutoff1.euclidean, p.max=.01, col='blue') #Plot eigenvectors
proc.nmds.nonnorm.cutoff1.euclidean.autotransform <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
stressplot(proc.nmds.nonnorm.cutoff1.euclidean.autotransform) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1 #Duplicate dataframe
stressplot(proc.nmds.nonnorm.cutoff1.euclidean) #Make Shepard plot
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-13-NMDS-TechnicalReplication-NonNormalized.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinates <- proc.nmds.nonnorm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
NMDSCoordinatesNonNormalizedCutoff1 <- proc.nmds.nonnorm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNonNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNonNormalizedCutoff1)/2 #Calculate the number of samples
nSamples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
sampleDistancesNonNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNonNormalizedCutoff1
sampleDistancesNonNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNonNormalizedCutoff1[i,1]-NMDSCoordinatesNonNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNonNormalizedCutoff1[i+1,1]-NMDSCoordinatesNonNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNonNormalizedCutoff1[i]) #Print the distance value
}
sampleDistancesNonNormalizedCutoff1 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinatesNonNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNonNormalizedCuttof1 <- rownames(NMDSCoordinatesNonNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNonNormalizedCuttof1 #Confirm vector creation
technicalReplicateDistancesNonNormalizedCuttof1 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof1[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff1[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNonNormalizedCuttof1) #Confirm dataframe creation
tail(technicalReplicateDistancesNonNormalizedCuttof1) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
SRMDataNMDSNonNormalizedPivoted
View(SRMDataNMDSNonNormalizedPivoted)
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-07-SRM-Data-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
SRMDataNMDSNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted and normalized data from first technical replication script
head(SRMDataNMDSNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNormalizedPivoted) <- SRMDataNMDSNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNormalizedPivoted) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1[-c(1, 2, 3, 18, 21, 22, 28, 43, 55, 76, 85, 86, 87, 88, 89, 90, 91, 92, 93, 103, 106, 109, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff1) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1[-88,]
rownames(SRMDataNMDSNormalizedPivotedCutoff1) #Confirm changes
SRMDataNMDSNormalizedPivotedCorrectedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff1[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff1)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff1) #Confirm there are no NAs
area.t2 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff1) #Transpose the file so that rows and columns are switched
head(area.t2) #Confirm transposition
area.tra2 <- (area.t2+1) #Add 1 to all values before transforming
area.tra2 <- data.trans(area.tra2, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff1.euclidean <- metaMDS(area.t2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff1.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.norm.cutoff1.euclidean.log <- metaMDS(area.tra2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
ordiplot(proc.nmds.norm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. This is super messy!
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.norm.cutoff1.euclidean.log <- metaMDS(area.tra2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance and log transformed data
ordiplot(proc.nmds.norm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. This is super messy!
proc.nmds.norm.cutoff1.euclidean.autotransform <- metaMDS(area.t2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation. Stress is (nearly) zero - you may have insufficient data
ordiplot(proc.nmds.norm.cutoff1.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. Also not good.
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff1.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
NMDSCoordinatesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
NMDSCoordinatesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
View(NMDSCoordinatesNonNormalizedCutoff1)
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff1 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof1 <- rownames(NMDSCoordinatesNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof1 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof1 <- data.frame(Sample = technicalReplicatesNormalizedCuttof1[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff1[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof1) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof1) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof1$Sample, y = technicalReplicateDistancesNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff1.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof1$Sample, y = technicalReplicateDistancesNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1 #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNonNormalizedPivoted
SRMDataNMDSNonNormalizedPivoted
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-07-SRM-Data-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
head(SRMDataNMDSNonNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNonNormalizedPivoted) <- SRMDataNMDSNonNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNonNormalizedPivoted) #Confirm changes
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1-3, 12, 15-17, 48-50, 56, 57-65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t3 <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
area.t3 <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t3) #Confirm transposition
area.tra3 <- (area.t3+1) #Add 1 to all values before transforming
area.tra3 <- data.trans(area.tra3, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.cutoff2.euclidean <- metaMDS(area.t3, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
proc.nmds.nonnorm.cutoff2.euclidean <- metaMDS(area.t3, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.nonnorm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNonNormalizedCutoff2 <- proc.nmds.nonnorm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNonNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNonNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNonNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNonNormalizedCutoff1
sampleDistancesNonNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNonNormalizedCutoff2[i,1]-NMDSCoordinatesNonNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNonNormalizedCutoff2[i+1,1]-NMDSCoordinatesNonNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNonNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNonNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not pairs of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNonNormalizedCuttof2 <- rownames(NMDSCoordinatesNonNormalizedCutoff2) #Save rownames as a new vector
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNonNormalizedCuttof2) #Confirm dataframe creation
tail(technicalReplicateDistancesNonNormalizedCuttof2) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-NonNormalized-Cutoff2.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNormalizedPivoted
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t4 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t4) #Confirm transposition
area.tra4 <- (area.t4+1) #Add 1 to all values before transforming
area.tra4 <- data.trans(area.tra4, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff2.euclidean <- metaMDS(area.t4, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff2[i] <- sqrt((sampleDistancesNormalizedCutoff2[i,1]-sampleDistancesNormalizedCutoff2[i,2])^2 + (sampleDistancesNormalizedCutoff2[i+1,1]-sampleDistancesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(sampleDistancesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(sampleDistancesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
SRMDataNMDSNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted and normalized data from first technical replication script
head(SRMDataNMDSNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNormalizedPivoted) <- SRMDataNMDSNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNormalizedPivoted) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t4 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t4) #Confirm transposition
area.tra4 <- (area.t4+1) #Add 1 to all values before transforming
area.tra4 <- data.trans(area.tra4, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff2.euclidean <- metaMDS(area.t4, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof2 <- rownames(NMDSCoordinatesNormalizedCutoff2) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof2 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof2) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof2) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof2$Sample, y = technicalReplicateDistancesNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof2$Sample, y = technicalReplicateDistancesNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 43, 44, 45, 46, 47, 48, 50, 52, 55, 56, 57, 64, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 103, 104, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff3) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 43, 44, 45, 46, 47, 48, 50, 52, 55, 56, 57, 64, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 103, 104, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff3) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
rownames(SRMDataNMDSNormalizedPivotedCutoff3)
SRMDataNMDSNormalizedPivotedCorrectedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff3[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff3)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff3) #Confirm there are no NAs
area.t5 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff3) #Transpose the file so that rows and columns are switched
head(area.t5) #Confirm transposition
area.tra5 <- (area.t5+1) #Add 1 to all values before transforming
area.tra5 <- data.trans(area.tra5, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff3.euclidean <- metaMDS(area.t5, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff3.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff3.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff3.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff3.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff3 <- proc.nmds.norm.cutoff3.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff3) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff3)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff3 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff3[i] <- sqrt((NMDSCoordinatesNormalizedCutoff3[i,1]-NMDSCoordinatesNormalizedCutoff3[i,2])^2 + (NMDSCoordinatesNormalizedCutoff3[i+1,1]-NMDSCoordinatesNormalizedCutoff3[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff3[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff3 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof3 <- rownames(NMDSCoordinatesNormalizedCutoff3) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof3 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof3 <- data.frame(Sample = technicalReplicatesNormalizedCuttof3[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff3[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof3) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof3) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof3$Sample, y = technicalReplicateDistancesNormalizedCuttof3$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff3.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof3$Sample, y = technicalReplicateDistancesNormalizedCuttof3$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
