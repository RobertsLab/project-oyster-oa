SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1
View(SRMDataNMDSNonNormalizedPivotedCutoff1)
View(SRMDataNMDSNonNormalizedPivotedCutoff1)
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1)
area.t <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1) #Transpose the file so that rows and columns are switched
head(area.t)
area.tra <- (area.t+1) #Add 1 to all values before transforming
area.tra <- data.trans(area.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
stressplot(proc.nmds.nonnorm.cutoff1.euclidean) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean.log <- metaMDS(area.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.nonnorm.cutoff1.euclidean.log) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
vec.proc.nmds.nonnorm.cutoff1.euclidean <- envfit(proc.nmds.nonnorm.cutoff1.euclidean$points, area.t, perm = 1000) #Calculate loadings
plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
plot(vec.proc.nmds.nonnorm.cutoff1.euclidean, p.max=.01, col='blue') #Plot eigenvectors
proc.nmds.nonnorm.cutoff1.euclidean.autotransform <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
stressplot(proc.nmds.nonnorm.cutoff1.euclidean.autotransform) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1 #Duplicate dataframe
stressplot(proc.nmds.nonnorm.cutoff1.euclidean) #Make Shepard plot
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'bray', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.nonnorm.cutoff1.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-13-NMDS-TechnicalReplication-NonNormalized.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinates <- proc.nmds.nonnorm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
NMDSCoordinatesNonNormalizedCutoff1 <- proc.nmds.nonnorm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNonNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNonNormalizedCutoff1)/2 #Calculate the number of samples
nSamples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
sampleDistancesNonNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNonNormalizedCutoff1
sampleDistancesNonNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNonNormalizedCutoff1[i,1]-NMDSCoordinatesNonNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNonNormalizedCutoff1[i+1,1]-NMDSCoordinatesNonNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNonNormalizedCutoff1[i]) #Print the distance value
}
sampleDistancesNonNormalizedCutoff1 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinatesNonNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNonNormalizedCuttof1 <- rownames(NMDSCoordinatesNonNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNonNormalizedCuttof1 #Confirm vector creation
technicalReplicateDistancesNonNormalizedCuttof1 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof1[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff1[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNonNormalizedCuttof1) #Confirm dataframe creation
tail(technicalReplicateDistancesNonNormalizedCuttof1) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-NonNormalized-Cutoff1.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
plot(x = technicalReplicateDistancesNonNormalizedCuttof1$Sample, y = technicalReplicateDistancesNonNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
SRMDataNMDSNonNormalizedPivoted
View(SRMDataNMDSNonNormalizedPivoted)
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)
View(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A") #Import site and eelgrass condition information (i.e. biological replicate information)
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-07-SRM-Data-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
SRMDataNMDSNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted and normalized data from first technical replication script
head(SRMDataNMDSNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNormalizedPivoted) <- SRMDataNMDSNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNormalizedPivoted) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1[-c(1, 2, 3, 18, 21, 22, 28, 43, 55, 76, 85, 86, 87, 88, 89, 90, 91, 92, 93, 103, 106, 109, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff1) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1[-88,]
rownames(SRMDataNMDSNormalizedPivotedCutoff1) #Confirm changes
SRMDataNMDSNormalizedPivotedCorrectedCutoff1 <- SRMDataNMDSNormalizedPivotedCutoff1 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff1[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff1)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff1) #Confirm there are no NAs
area.t2 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff1) #Transpose the file so that rows and columns are switched
head(area.t2) #Confirm transposition
area.tra2 <- (area.t2+1) #Add 1 to all values before transforming
area.tra2 <- data.trans(area.tra2, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff1.euclidean <- metaMDS(area.t2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff1.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.norm.cutoff1.euclidean.log <- metaMDS(area.tra2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
ordiplot(proc.nmds.norm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. This is super messy!
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.norm.cutoff1.euclidean.log <- metaMDS(area.tra2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance and log transformed data
ordiplot(proc.nmds.norm.cutoff1.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. This is super messy!
proc.nmds.norm.cutoff1.euclidean.autotransform <- metaMDS(area.t2, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation. Stress is (nearly) zero - you may have insufficient data
ordiplot(proc.nmds.norm.cutoff1.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names. Also not good.
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff1.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff1.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
NMDSCoordinatesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
NMDSCoordinatesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
View(NMDSCoordinatesNonNormalizedCutoff1)
NMDSCoordinatesNormalizedCutoff1 <- proc.nmds.norm.cutoff1.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff1) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff1)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff1 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff1[i] <- sqrt((NMDSCoordinatesNormalizedCutoff1[i,1]-NMDSCoordinatesNormalizedCutoff1[i,2])^2 + (NMDSCoordinatesNormalizedCutoff1[i+1,1]-NMDSCoordinatesNormalizedCutoff1[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff1[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff1 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof1 <- rownames(NMDSCoordinatesNormalizedCutoff1) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof1 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof1 <- data.frame(Sample = technicalReplicatesNormalizedCuttof1[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff1[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof1) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof1) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof1$Sample, y = technicalReplicateDistancesNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff1.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof1$Sample, y = technicalReplicateDistancesNormalizedCuttof1$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCorrectedCutoff1 #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNonNormalizedPivoted
SRMDataNMDSNonNormalizedPivoted
SRMDataNMDSNonNormalizedPivoted <- read.csv("2017-09-07-SRM-Data-NMDS-Pivoted.csv", header = TRUE) #Import pivoted data from first technical replication script
head(SRMDataNMDSNonNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNonNormalizedPivoted) <- SRMDataNMDSNonNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNonNormalizedPivoted) #Confirm changes
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1-3, 12, 15-17, 48-50, 56, 57-65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
SRMDataNMDSNonNormalizedPivotedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNonNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNonNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t3 <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
area.t3 <- t(SRMDataNMDSNonNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t3) #Confirm transposition
area.tra3 <- (area.t3+1) #Add 1 to all values before transforming
area.tra3 <- data.trans(area.tra3, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.cutoff2.euclidean <- metaMDS(area.t3, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
proc.nmds.nonnorm.cutoff2.euclidean <- metaMDS(area.t3, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.nonnorm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.nonnorm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-NonNormalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.nonnorm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNonNormalizedCutoff2 <- proc.nmds.nonnorm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNonNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNonNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNonNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNonNormalizedCutoff1
sampleDistancesNonNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNonNormalizedCutoff2[i,1]-NMDSCoordinatesNonNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNonNormalizedCutoff2[i+1,1]-NMDSCoordinatesNonNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNonNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNonNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not pairs of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNonNormalizedCuttof2 <- rownames(NMDSCoordinatesNonNormalizedCutoff2) #Save rownames as a new vector
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNonNormalizedCuttof2) #Confirm dataframe creation
tail(technicalReplicateDistancesNonNormalizedCuttof2) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
technicalReplicateDistancesNonNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNonNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNonNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-NonNormalized-Cutoff2.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNonNormalizedCuttof2$Sample, y = technicalReplicateDistancesNonNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNormalizedPivoted
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t4 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t4) #Confirm transposition
area.tra4 <- (area.t4+1) #Add 1 to all values before transforming
area.tra4 <- data.trans(area.tra4, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff2.euclidean <- metaMDS(area.t4, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff1
sampleDistancesNormalizedCutoff2[i] <- sqrt((sampleDistancesNormalizedCutoff2[i,1]-sampleDistancesNormalizedCutoff2[i,2])^2 + (sampleDistancesNormalizedCutoff2[i+1,1]-sampleDistancesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(sampleDistancesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(sampleDistancesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
SRMDataNMDSNormalizedPivoted <- read.csv("2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv", header = TRUE) #Import pivoted and normalized data from first technical replication script
head(SRMDataNMDSNormalizedPivoted) #Confirm import
rownames(SRMDataNMDSNormalizedPivoted) <- SRMDataNMDSNormalizedPivoted$RowNames #Assign rownames
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-1] #Remove extraneous column
SRMDataNMDSNormalizedPivoted <- SRMDataNMDSNormalizedPivoted[,-93] #Remove RowNames column
head(SRMDataNMDSNormalizedPivoted) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNormalizedPivotedCorrectedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff2[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff2)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Confirm there are no NAs
area.t4 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff2) #Transpose the file so that rows and columns are switched
head(area.t4) #Confirm transposition
area.tra4 <- (area.t4+1) #Add 1 to all values before transforming
area.tra4 <- data.trans(area.tra4, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff2.euclidean <- metaMDS(area.t4, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff2.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff2.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff2 <- proc.nmds.norm.cutoff2.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff2) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff2)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff2 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff2[i] <- sqrt((NMDSCoordinatesNormalizedCutoff2[i,1]-NMDSCoordinatesNormalizedCutoff2[i,2])^2 + (NMDSCoordinatesNormalizedCutoff2[i+1,1]-NMDSCoordinatesNormalizedCutoff2[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff2[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff2 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof2 <- rownames(NMDSCoordinatesNormalizedCutoff2) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof2 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof2 <- data.frame(Sample = technicalReplicatesNormalizedCuttof2[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff2[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof2) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof2) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof2$Sample, y = technicalReplicateDistancesNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff2.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof2$Sample, y = technicalReplicateDistancesNormalizedCuttof2$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 43, 44, 45, 46, 47, 48, 50, 52, 55, 56, 57, 64, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 103, 104, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff3) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1, 2, 3, 4, 5, 6, 18, 19, 21, 22, 26, 28, 30, 43, 47, 55, 67, 68, 69, 70, 76, 77, 79, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 103, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff2 <- SRMDataNMDSNormalizedPivotedCutoff2[-c(1:3, 12, 15:17, 48:50, 56, 57:65),] #Remove peptides and proteins that don't fit the above criteria. I cut more than I expected.
rownames(SRMDataNMDSNormalizedPivotedCutoff2) #Confirm changes
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 43, 44, 45, 46, 47, 48, 50, 52, 55, 56, 57, 64, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 103, 104, 106, 107, 108, 109, 110, 111),] #Remove rows that don't make the cutoff
rownames(SRMDataNMDSNormalizedPivotedCutoff3) #See if any peptide has less than 2 transitions, and if any protein has less than 2 peptides remaining
SRMDataNMDSNormalizedPivotedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3[-c(1:3, 7, 16:17, 24:31),] #Remove peptides and proteins that don't fit the above criteria. There are maybe two proteins left
rownames(SRMDataNMDSNormalizedPivotedCutoff3)
SRMDataNMDSNormalizedPivotedCorrectedCutoff3 <- SRMDataNMDSNormalizedPivotedCutoff3 #Duplicate dataframe
SRMDataNMDSNormalizedPivotedCorrectedCutoff3[is.na(SRMDataNMDSNormalizedPivotedCorrectedCutoff3)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNormalizedPivotedCorrectedCutoff3) #Confirm there are no NAs
area.t5 <- t(SRMDataNMDSNormalizedPivotedCorrectedCutoff3) #Transpose the file so that rows and columns are switched
head(area.t5) #Confirm transposition
area.tra5 <- (area.t5+1) #Add 1 to all values before transforming
area.tra5 <- data.trans(area.tra5, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.norm.cutoff3.euclidean <- metaMDS(area.t5, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance.
stressplot(proc.nmds.norm.cutoff3.euclidean) #Make Shepard plot
ordiplot(proc.nmds.norm.cutoff3.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Normalized-Cutoff3.jpeg", width = 1000, height = 1000)
ordiplot(proc.nmds.norm.cutoff3.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinatesNormalizedCutoff3 <- proc.nmds.norm.cutoff3.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinatesNormalizedCutoff3) #Confirm dataframe creation
nSamples <- length(NMDSCoordinatesNormalizedCutoff3)/2 #Calculate the number of samples
sampleDistancesNormalizedCutoff3 <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinatesNormalizedCutoff2
sampleDistancesNormalizedCutoff3[i] <- sqrt((NMDSCoordinatesNormalizedCutoff3[i,1]-NMDSCoordinatesNormalizedCutoff3[i,2])^2 + (NMDSCoordinatesNormalizedCutoff3[i+1,1]-NMDSCoordinatesNormalizedCutoff3[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistancesNormalizedCutoff3[i]) #Print the distance value
}
sampleDistancesNormalizedCutoff3 #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicatesNormalizedCuttof3 <- rownames(NMDSCoordinatesNormalizedCutoff3) #Save rownames as a new vector
technicalReplicatesNormalizedCuttof3 #Confirm vector creation
technicalReplicateDistancesNormalizedCuttof3 <- data.frame(Sample = technicalReplicatesNormalizedCuttof3[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistancesNormalizedCutoff3[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistancesNormalizedCuttof3) #Confirm dataframe creation
tail(technicalReplicateDistancesNormalizedCuttof3) #Confirm dataframe creation
plot(x = technicalReplicateDistancesNormalizedCuttof3$Sample, y = technicalReplicateDistancesNormalizedCuttof3$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-10-10-Transition-Replicate-Correlations/2017-10-13-NMDS-TechnicalReplication-Ordination-Distances-Normalized-Cutoff3.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistancesNormalizedCuttof3$Sample, y = technicalReplicateDistancesNormalizedCuttof3$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
SRMAreas <- read.csv("2017-09-12-Gigas-SRM-ReplicatesOnly-PostDilutionCurve-NoPivot-RevisedSettings-Report.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A", fileEncoding="UTF-8-BOM") #Import site and eelgrass condition information (i.e. biological replicate information), using specific file encoding information
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
#write.csv(x = masterSRMDataBiologicalReplicates, file = "2017-09-07-Master-SRM-Data-BiologicalReplicates-NoBlanks-NoPivot.csv") #Write out master dataframe
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
tail(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 10, 11)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
SRMDataNonNormalizedNMDS <- SRMDataNMDS #Create a duplicate dataframe
SRMDataNonNormalizedNMDS <- SRMDataNMDS[,-6] #Remove TIC column
head(SRMDataNonNormalizedNMDS) #Confirm creation
#My first step is to change my dataframe from long to wide (i.e. cast it)
library(reshape2) #Instal package to pivot table
SRMDataNMDSNonNormalizedPivoted <- dcast(SRMDataNonNormalizedNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSNonNormalizedPivoted) #Confirm cast.
SRMDataNMDSNonNormalizedPivoted$RowNames <- paste(SRMDataNMDSNonNormalizedPivoted$Protein.Name, SRMDataNMDSNonNormalizedPivoted$Peptide.Sequence, SRMDataNMDSNonNormalizedPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column merge
SRMDataNMDSNonNormalizedPivoted <- SRMDataNMDSNonNormalizedPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSNonNormalizedPivoted) #Confirm column removal
#write.csv(SRMDataNMDSNonNormalizedPivoted, file = "2017-09-07-SRM-Data-NMDS-Pivoted.csv") #Wrote out as .csv to make future analyses easier.
#Now I can make an NMDS plot
#Load the source file for the biostats package
source("biostats.R") #Either load the source R script or copy paste
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSNonNormalizedPivotedCorrected <- SRMDataNMDSNonNormalizedPivoted #Duplicate dataframe
SRMDataNMDSNonNormalizedPivotedCorrected[is.na(SRMDataNMDSNonNormalizedPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSNonNormalizedPivotedCorrected) #Confirm there are no NAs
area.protID <- SRMDataNMDSNonNormalizedPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID) <- SRMDataNMDSNonNormalizedPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID) #Confirm changes
area.t <- t(area.protID) #Transpose the file so that rows and columns are switched
head(area.t) #Confirm transposition
area.tra <- (area.t+1) #Add 1 to all values before transforming
area.tra <- data.trans(area.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.nonnorm.euclidean <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
#stressplot(proc.nmds.nonnorm.euclidean) #Make Shepard plot
#ordiplot(proc.nmds.nonnorm.euclidean) #Plot basic NMDS
#vec.proc.nmds.nonnorm.euclidean <- envfit(proc.nmds.nonnorm.euclidean$points, area.t, perm = 1000) #Calculate loadings
ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
#proc.nmds.nonnorm.euclidean.log <- metaMDS(area.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
#stressplot(proc.nmds.nonnorm.euclidean.log) #Make Shepard plot
#ordiplot(proc.nmds.nonnorm.euclidean.log) #Plot basic NMDS
#ordiplot(proc.nmds.nonnorm.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#proc.nmds.nonnorm.euclidean.autotransform <- metaMDS(area.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
#stressplot(proc.nmds.nonnorm.euclidean.autotransform) #Make Shepard plot
#ordiplot(proc.nmds.nonnorm.euclidean.autotransform) #Plot basic NMDS
#ordiplot(proc.nmds.nonnorm.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#jpeg(filename = "2017-09-11-NMDS-TechnicalReplication-NonNormalized.jpeg", width = 1000, height = 1000)
#ordiplot(proc.nmds.nonnorm.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#dev.off()
#Only the euclidean non-transformed version gives me an NMDS plot, but there looks like there's variation that should be accounted for by normalizing.
#### NORMALIZE BY TIC VALUES ####
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
#### REFORMAT DATAFRAME FOR NMDS ####
#The goal is to have the row names of my new dataframe be Protein/Peptides/Transitions, with the column names as the sample number
#My first step is to change my dataframe from long to wide (i.e. cast it)
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence + Fragment.Ion ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence, SRMDataNMDSPivoted$Fragment.Ion) #Merge Protein, Peptide and Transition information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:3)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
#write.csv(SRMDataNMDSPivoted, file = "2017-09-11-SRM-Data-Normalized-NMDS-Pivoted.csv") #Wrote out as .csv to make future analyses easier.
#### NMDS PLOT ####
#Load the source file for the biostats package
source("biostats.R") #Either load the source R script or copy paste.
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected[-93] #Save all area data as a new dataframe
rownames(area.protID2) <- SRMDataNMDSPivotedCorrected[,93] #Make sure last column of protein names is recognized as row names instead of values
head(area.protID2) #Confirm changes
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
head(area2.t) #Confirm transposition
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean) #Plot basic NMDS
vec.proc.nmds.euclidean <- envfit(proc.nmds.euclidean$points, area2.t, perm = 1000) #Calculate loadings
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
#stressplot(proc.nmds.euclidean.log) #Make Shepard plot
#ordiplot(proc.nmds.euclidean.log) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
#stressplot(proc.nmds.euclidean.autotransform) #Make Shepard plot
#ordiplot(proc.nmds.euclidean.autotransform) #Plot basic NMDS
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#jpeg(filename = "2017-09-08-NMDS-TechnicalReplication-Normalized.jpeg", width = 1000, height = 1000)
#ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
#dev.off()
#### CALCULATE DISTANCES BETWEEN TECHNICAL REPLICATE ORDINATIONS ####
NMDSCoordinates <- proc.nmds.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinates) #Confirm dataframe creation
nSamples <- length(NMDSCoordinates)/2 #Calculate the number of samples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinates) #Save rownames as a new vector
technicalReplicates #Confirm vector creation
technicalReplicateDistances <- data.frame(Sample = technicalReplicates[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistances[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
tail(technicalReplicateDistances) #Confirm dataframe creation
#### PLOT DISTANCES BETWEEN TECHNICAL REPLICATE ORDINATIONS ####
#jpeg(filename = "2017-09-08-NMDS-TechnicalReplication-Ordination-Distances.jpeg", width = 1000, height = 1000)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
#dev.off()
install.packages("vegan")
