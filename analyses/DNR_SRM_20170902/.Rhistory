getwd()
setwd("../../..")
getwd()
setwd("/Users/yaaminivenkataraman/Documents/project-oyster-oa/analyses/DNR_SRM_20170902/2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset")
getwd()
setwd("../..")
getwd()
SRMAreas <- read.csv("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-Gigas-SRM-Good-Samples-Total-Area.csv", na.strings = "#N/A") #Specify Skyline's special way of designating N/A values
head(SRMAreas) #Confirm import
tail(SRMAreas) #Confirm import
sequenceFile <- read.csv("2017-07-28-SRM-Samples-Sequence-File.csv", na.strings = "N/A") # Import sequence file
head(sequenceFile) #Confirm import
sequenceFile <- sequenceFile[,c(2,3,8)] #Keep the Replicate.Name, Comment and TIC columns
names(sequenceFile) <- c("Replicate.Name", "Sample.Number", "TIC")
head(sequenceFile) #Confirm change
masterSRMData <- merge(x = SRMAreas, y = sequenceFile, by = "Replicate.Name") #Merge the sample names and replicate names to use for analysis.
head(masterSRMData) #Confirm merge
tail(masterSRMData) #Confirm merge
biologicalReplicates <- read.csv("2017-09-06-Biological-Replicate-Information.csv", na.strings = "N/A", fileEncoding="UTF-8-BOM") #Import site and eelgrass condition information (i.e. biological replicate information), using specific file encoding information
head(biologicalReplicates) #Confirm import
tail(biologicalReplicates) #Confirm import
masterSRMDataBiologicalReplicates <- merge(x = masterSRMData, y = biologicalReplicates, by = "Sample.Number") #Add biological replicate information to master list.
head(masterSRMDataBiologicalReplicates) #Confirm change
SRMDataNMDS <- masterSRMDataBiologicalReplicates #Duplicate master list into a new dataframe
head(SRMDataNMDS) #Confirm copy
SRMDataNMDS <- SRMDataNMDS[,-c(2, 5, 7, 8, 11, 12)] #Remove extraneous columns: Replicate.Name, Transition, Peptide.Retention.Time, Area, Site, Eelgrass
head(SRMDataNMDS) #Confirm column removal
SRMDataNMDS <- SRMDataNMDS[! SRMDataNMDS$Protein.Name %in% "PRTC peptides", ] #Remove PRTC peptide data
head(SRMDataNMDS) #Confirm removal
transform(SRMDataNMDS, Area = as.numeric(Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, Total.Area = as.numeric(Total.Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, TIC = as.numeric(TIC)) #Make sure TIC is recognized as a numeric variable
is.numeric(SRMDataNMDS$TIC) #Confirm change
is.numeric(SRMDataNMDS$Area) #Confirm change
transform(SRMDataNMDS, Total.Area = as.numeric(Total.Area)) #Make sure Area is recognized as a numeric variable
is.numeric(SRMDataNMDS$Area) #Confirm change
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
SRMNormalizedDataNMDS <- SRMDataNMDS #Duplicate dataframe
SRMNormalizedDataNMDS$Normalized.Area <- SRMNormalizedDataNMDS$Total.Area/SRMDataNMDS$TIC #Divide areas by corresponding TIC values
head(SRMNormalizedDataNMDS) #Confirm division
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-c(5,6)] #Remove nonnormalized area and TIC columns
head(SRMNormalizedDataNMDS) #Confirm column removal
SRMNormalizedDataNMDS
View(SRMNormalizedDataNMDS)
SRMNormalizedDataNMDS <- SRMNormalizedDataNMDS[,-4] #Remove fragment ion column
head(SRMNormalizedDataNMDS) #Confirm changes
SRMNormalizedDataNMDS <- unique(SRMNormalizedDataNMDS) #Keep only unique rows
View(SRMNormalizedDataNMDS)
library(reshape2) #Instal package to pivot table
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
SRMDataNMDSPivoted$RowNames <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence) #Merge Protein and Peptide information into one column
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:2)] #Remove unmerged columns
head(SRMDataNMDSPivoted) #Confirm column removal
head(SRMDataNMDSPivoted) #Confirm column removal
source("biostats.R") #Either load the source R script or copy paste.
install.packages("vegan") #Install vegan package
library(vegan)
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
SRMDataNMDSPivoted <- dcast(SRMNormalizedDataNMDS, Protein.Name + Peptide.Sequence ~ Sample.Number) #Cast table! Protein/Peptides/Transitions remain as columns with Sample Number as column headers. Normalized.Area used as value column by default.
head(SRMDataNMDSPivoted) #Confirm cast.
rownames(SRMDataNMDSPivoted) <- paste(SRMDataNMDSPivoted$Protein.Name, SRMDataNMDSPivoted$Peptide.Sequence) #Set Protein and Peptide information as row names
head(SRMDataNMDSPivoted) #Confirm column merge
SRMDataNMDSPivoted <- SRMDataNMDSPivoted[,-c(1:2)] #Remove protein and peptide name columns
head(SRMDataNMDSPivoted) #Confirm column removal
SRMDataNMDSPivotedCorrected <- SRMDataNMDSPivoted #Duplicate dataframe
SRMDataNMDSPivotedCorrected[is.na(SRMDataNMDSPivotedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSPivotedCorrected) #Confirm there are no NAs
area.protID2 <- SRMDataNMDSPivotedCorrected #Save all area data as a new dataframe
head(area.protID2) #Confirm changes
head(area.protID2) #Confirm changes
area2.t <- t(area.protID2) #Transpose the file so that rows and columns are switched
head(area2.t) #Confirm transposition
area2.tra <- (area2.t+1) #Add 1 to all values before transforming
area2.tra <- data.trans(area2.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.euclidean <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
stressplot(proc.nmds.euclidean) #Make Shepard plot
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
plot(vec.proc.nmds.euclidean, p.max=.01, col='blue') #Plot eigenvectors
proc.nmds.euclidean.log <- metaMDS(area2.tra, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance
stressplot(proc.nmds.euclidean.log) #Make Shepard plot
ordiplot(proc.nmds.euclidean.log, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
proc.nmds.euclidean.autotransform <- metaMDS(area2.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = TRUE) #Make MDS dissimilarity matrix using euclidean distance and autotransformation
stressplot(proc.nmds.euclidean.autotransform) #Make Shepard plot
ordiplot(proc.nmds.euclidean.autotransform, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-TechnicalReplication-Normalized.jpeg", width = 1000, height = 750)
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites") #Plot refined NMDS displaying only samples with their names
dev.off()
NMDSCoordinates <- proc.nmds.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinates) #Confirm dataframe creation
nSamples <- length(NMDSCoordinates)/2 #Calculate the number of samples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinates) #Save rownames as a new vector
technicalReplicates #Confirm vector creation
technicalReplicateDistances <- data.frame(Sample = technicalReplicates[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistances[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
tail(technicalReplicateDistances) #Confirm dataframe creation
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
jpeg(filename = "2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-TechnicalReplication-Ordination-Distances.jpeg", width = 1000, height = 1000)
jpeg(filename = "2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-TechnicalReplication-Ordination-Distances.jpeg", width = 1000, height = 750)
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
dev.off()
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.7) #Plot refined NMDS displaying only samples with their names
jpeg(filename = "2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-TechnicalReplication-Normalized.jpeg", width = 1000, height = 750)
ordiplot(proc.nmds.euclidean, choices = c(1,2), type = "text", display = "sites", cex = 0.7) #Plot refined NMDS displaying only samples with their names
dev.off()
getwd()
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
source(2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R) #Information from previous script
getwd()
setwd("analyses/DNR_SRM_20170902/")
getwd()
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
getwd()
setwd("analyses/DNR_SRM_20170902/")
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
setwd("analyses/DNR_SRM_20170902/")
source("2017-10-10-Troubleshooting/2017-11-05-Integrated-Dataset/2017-11-05-NMDS-for-Technical-Replication.R") #Information from previous script
install.packages("vegan")
head(SRMDataNMDSPivotedCorrected) #Dataset I'll use to average technical replicates, from my first R script (NMDS for Technical Replication)
SRMDataNMDSAveraged <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store averaged values
row.names(SRMDataNMDSAveraged) <- SRMDataNMDSPivotedCorrected$RowNames #Add row names
head(SRMDataNMDSAveraged) #Confirm changes
for(i in 1:(length(SRMDataNMDSPivotedCorrected))) { #Average normalized area values for consecutive columns
SRMDataNMDSAveraged[,i] <- (SRMDataNMDSPivotedCorrected[,i]+SRMDataNMDSPivotedCorrected[,i+1])/2
}
head(SRMDataNMDSAveraged) #Confirm averaging
SRMDataNMDSAveraged <- SRMDataNMDSAveraged[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Remove even-numbered columns, since those consecutive columns are not technical replicates
head(SRMDataNMDSAveraged) #Confirm column removal
colnames(SRMDataNMDSAveraged) <- technicalReplicates[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Add column names
colnames(SRMDataNMDSAveraged) #Confirm column naming
head(SRMDataNMDSAveraged) #Confirm column naming
head(SRMDataNMDSPivotedCorrected) #Dataset I'll use to average technical replicates, from my first R script (NMDS for Technical Replication)
SRMDataNMDSAveraged <- data.frame(x = rep(x = 0, times = 111),
y = rep(x = 0, times = 111)) #Create an empty dataframe to store averaged values
row.names(SRMDataNMDSAveraged) <- row.names(SRMDataNMDSPivotedCorrected) #Add row names
row.names(SRMDataNMDSAveraged) <- rownames(SRMDataNMDSPivotedCorrected) #Add row names
head(SRMDataNMDSPivotedCorrected) #Dataset I'll use to average technical replicates, from my first R script (NMDS for Technical Replication)
row.names(SRMDataNMDSPivotedCorrected)
row.names(SRMDataNMDSAveraged) <- row.names(SRMDataNMDSPivotedCorrected) #Add row names
SRMDataNMDSPivotedCorrected
View(SRMDataNMDSPivotedCorrected)
SRMDataNMDSAveraged <- data.frame(x = rep(x = 0, times = length(SRMDataNMDSPivotedCorrected)),
y = rep(x = 0, times = length(SRMDataNMDSPivotedCorrected))) #Create an empty dataframe to store averaged values
row.names(SRMDataNMDSAveraged) <- row.names(SRMDataNMDSPivotedCorrected) #Add row names
SRMDataNMDSAveraged <- data.frame(x = rep(x = 0, times = length(SRMDataNMDSPivotedCorrected$`O01-1`)),
y = rep(x = 0, times = length(SRMDataNMDSPivotedCorrected$`O01-1`))) #Create an empty dataframe to store averaged values
row.names(SRMDataNMDSAveraged) <- row.names(SRMDataNMDSPivotedCorrected) #Add row names
head(SRMDataNMDSAveraged) #Confirm changes
for(i in 1:(length(SRMDataNMDSPivotedCorrected))) { #Average normalized area values for consecutive columns
SRMDataNMDSAveraged[,i] <- (SRMDataNMDSPivotedCorrected[,i]+SRMDataNMDSPivotedCorrected[,i+1])/2
}
head(SRMDataNMDSAveraged) #Confirm averaging
SRMDataNMDSAveraged <- SRMDataNMDSAveraged[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Remove even-numbered columns, since those consecutive columns are not technical replicates
head(SRMDataNMDSAveraged) #Confirm column removal
colnames(SRMDataNMDSAveraged) <- technicalReplicates[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Add column names
colnames(SRMDataNMDSAveraged) #Confirm column naming
NMDSCoordinates <- proc.nmds.euclidean$points #Save NMDS coordinates of each point in a new dataframe
head(NMDSCoordinates) #Confirm dataframe creation
nSamples <- length(NMDSCoordinates)/2 #Calculate the number of samples
sampleDistances <- vector(length = nSamples) #Create an empty vector to store distance values
for(i in 1:nSamples) { #For rows in NMDSCoordinates
sampleDistances[i] <- sqrt((NMDSCoordinates[i,1]-NMDSCoordinates[i,2])^2 + (NMDSCoordinates[i+1,1]-NMDSCoordinates[i+1,2])^2) #Calculate distance between ordinations
print(sampleDistances[i]) #Print the distance value
}
sampleDistances #Confirm vector creation. This vector has all consecutive pairs, including those that are not paris of technical replicates. I need to retain just the odd numbered rows.
technicalReplicates <- rownames(NMDSCoordinates) #Save rownames as a new vector
technicalReplicates #Confirm vector creation
technicalReplicateDistances <- data.frame(Sample = technicalReplicates[seq(from = 1, to = nSamples, by = 2)],
Distance = sampleDistances[seq(from = 1, to = nSamples, by = 2)]) #Create a new dataframe with just odd numbered row distances (technical replicate pairs)
head(technicalReplicateDistances) #Confirm dataframe creation
tail(technicalReplicateDistances) #Confirm dataframe creation
colnames(SRMDataNMDSAveraged) <- technicalReplicates[seq(from = 1, to = (length(SRMDataNMDSPivotedCorrected)-1), by = 2)] #Add column names
colnames(SRMDataNMDSAveraged) #Confirm column naming
SRMDataNMDSAveragedCorrected <- SRMDataNMDSAveraged #Duplicate dataframe
SRMDataNMDSAveragedCorrected[is.na(SRMDataNMDSAveragedCorrected)] <- 0 #Replace NAs with 0s
head(SRMDataNMDSAveragedCorrected) #Confirm there are no NAs
area.protID4 <- SRMDataNMDSAveragedCorrected #Save all area data as a new dataframe
head(area.protID4) #Confirm changes
area4.t <- t(area.protID4) #Transpose the file so that rows and columns are switched
head(area4.t) #Confirm transposition
area4.tra <- (area4.t+1) #Add 1 to all values before transforming
area4.tra <- data.trans(area4.tra, method = 'log', plot = FALSE) #log(x+1) transformation
proc.nmds.averaged.euclidean <- metaMDS(area4.t, distance = 'euclidean', k = 2, trymax = 10000, autotransform = FALSE) #Make MDS dissimilarity matrix using euclidean distance. Julian confirmed that I should use euclidean distances, and not bray-curtis
stressplot(proc.nmds.averaged.euclidean) #Make Shepard plot
temporaryData <- data.frame(Sample.Number = technicalReplicates,
y = rep(x = 0, times = length(technicalReplicates))) #Create a temporary dataframe with technical replicate names used in NMDS
ordiplot(proc.nmds.averaged.euclidean, choices = c(1,2), type = "points", display = "sites") #Plot basic NMDS
temporaryData <- data.frame(Sample.Number = technicalReplicates,
y = rep(x = 0, times = length(technicalReplicates))) #Create a temporary dataframe with technical replicate names used in NMDS
head(temporaryData) #Confirm dataframe creation
NMDSColorShapeCustomization <- merge(x = temporaryData, y = biologicalReplicates, by = "Sample.Number") #Merge biological information with samples used
head(NMDSColorShapeCustomization) #Confirm merge
tail(NMDSColorShapeCustomization) #Confirm merge
NMDSColorShapeCustomization <- NMDSColorShapeCustomization[,-2] #Remove empty column
plot(x = technicalReplicateDistances$Sample, y = technicalReplicateDistances$Distance, type = "line", xlab = "Sample", ylab = "Distance between Ordinations")
